<!--web design thread-->

tag names went from appearance to semantics; ie. b to strong, i to em.
anchor tags: turns in side tags into hypertags
p: paragraph
strong: make strong
em: italicize 
blockquote: a section that is quoted from antoerh source..> really just has specific css properties.

head contains meta data: data about data. one of which is which char set to use so that it can handle the expanded range of chracters(unicode). <meta charset="utf-8">
void element are self-closing tags.

for link/anchor tags, atrribs: href(hypertext reference), target="_blank"(opens link in a new tab)
img tags: src, alt:displayed if img not rendered.
self closing tags end in > or />
Linking srcs from other sites is called hotlinking
download using linux commandline: curl -o imges/kitten.job -OL url.com
gravatar allows you to associate std imgs with particular email addresses, used to display profile pics on var sites.

code tag desigend to display pieces of markup or src code. 
In monspace font, all letters have the same width.
inline element: <strong>/ <em>. all tags that modify text.
block element: divides page's text up.

Tables: tr: table row. First row usually includes labels for table's columns via table headers: th tag.
ie: <table><tr><th>Tag</th></tr></table>... adding extra rows consists of simply adding <tr><td>...</td></tr>
character entity reference: &ndash;.
lists: ordered<ol> unordered <ul> List: <li>
Navigation menus:
style attributes: append style="" as an element to any html tag
div is a block element and span is an inline element.
blockquote tag for quotoing blocks of text

Float: is a CSS property
height="200px" to img property restricts heigt to 200 pixels 
When resizing, use either height or width, not both, as both forces browser to attempt to respect both numbers which can result in wierd image resizing effects.
To get text to flow around an image, CSS property float. When an element is floating to the left or right(no center), all the inline content around it will flow around the floated element. 
Applying margins of empty space: 
-3 styles applicable to imaginary boxes: margin, border, padding.
Add  property: margin:40px applies to all 4 sides.
margin: toppx rightpx botpx leftpx... or smiply margin-right/left/top/bottom
using auto causes everything else to be automatically the same on all sides. margin: 0 auto; would make the top and bottom 0, and left and right automatically margined.
This is good for centering things that can't be centered w
ith text-align.
img is an inline element, and margin only works on block elements, thus to turn inlines to blocks, use style display: block, 
padding pushes content away from the edges.

CSS:
vendor prefix: -webkit-, -moz-, -ms- allows applide style to target specific browsers.
ie:
  -webkit-transition: all 0.1s linear;
  -moz-transition: all 0.1s linear;
  -ms-transition: all 0.1s linear;
  transition: all 0.1s linear;

 Git steps:
 $ git init
$ git add -A
$ git commit -m "Initialize repo"
$ git remote add origin <repo url>
$ git push -u origin master
$ git checkout -b gh-pages
$ git push -u origin gh-pages
div(css selector){
	declaration(border[property]: 1px solid black[value])
}

class inheritance: div a{color: green;}
class: .poo... id: #doo
background-color
border
color

multiple classes: class="bio-box red"
css specificity. ids have higher specificity than classes, thus ids will override classes, and 
To make classes have presidence over id, put em together like #exec-bio.alert{ background: red;
}

width: 100%; width of block spans entire page cept the margins

In CSS, styling rules flow down from parents to children unless another style interrupts and takes priority.

In case of conflicting rules, the final rule is the one that applies.

CSS PRIORITY RULES !IMPORTANT!!!:
1 	Importance 	Adding !important (e.g., “width: 100% !important”) to a value overrides all other similar styles (but never use !important (Box 8)
2 	Inline 	A declaration that is put on an element using style=
3 	Media Type 	When a style is applied through a media query (more in Chapter 9)
4 	User defined 	Most browsers have the accessibility feature: a user defined CSS
5 	Selector specificity 	Styling applied via a class or id overwrites generic styling
6 	Rule order 	The last style written has priority
7 	Parent inheritance 	If there is no style specified, then children inherit styles from their parent
8 	CSS 	CSS rules from a stylesheet or style block that are applied to generic elements.
9 	Browser defaults 	Lowest priority, these are the default styles that browsers ship with


background-image: url() by default repeats an image both horizontally and vertically.
repeat vertically.. background-repeat: repeat-x(horizontally),, repeat-y(vertically)

background-repeat: no-repeat...background-position: right top;
To make background image fixed(not scroll with rest of page) use background-attachment: fixed.
shorthand property for background is 
body{
	background: $ffffff url("....png") no-repeat fixed;
	background-size: 100% 100% makes background immunite to zooming
}

Specificity Styling(Priority):
Simple HTML selector 	em {color: #fff;} 	1
HTML selector targeting element inside another element 	h1 em {color: #00ff00;} 	2
CSS class name 	.alert {color: #ff0000;} 	1,0
HTML element with a class name 	p.safe {color: #0000ff;} 	1,1
CSS id 	#thing {color: #823706;} 	1,0,0
CSS id with a class name 	#thing .property {color: #823706;} 	1,1,0
Inline style 	style="color: transparent;" 	1,0,0,0

browsers read CSS selectors from right to left.
Whichever one is more specific is the one likely to be chosen.

px and point. px = 1/96 inch? pnt = 1/72 inch
percentage more used in sizing containers than say fonts.
em, relative size unit for sizingtext.
he name comes from the approximate width of the letter m, but this usage is mainly historical; in CSS, one em represents a number of pixels equal to the current font size of any given element’s parent container. If there is no font size that is inherited, then the default page font size is used.
One of the things that makes ems useful, in comparison to something like pixel sizing, is that they automatically change value based on the font size that is inherited by the parent object that they are contained in. This means that if you used em sizing throughout your site, you can modify the entire site’s text simply by changing a single base font size, and all the fonts in all the child containers will resize in correct proportion based on this new declared font size.

One important property of em units is that they are cumulative: if an element has font size set to 0.5em appears inside an element whose font size is also 0.5em, then the resulting font size for that bottom child element is 0.5×0.5= 0.25em

Logo b a3519f7b2d8b0a238a034a5bd3b434e0ca93f027181db08fb3e6167caed45be9

    The Rails Tutorial Courses log in sign up 

Logo b a3519f7b2d8b0a238a034a5bd3b434e0ca93f027181db08fb3e6167caed45be9 LEARN ENOUGH

    CSS & Layout
        1 Introduction to CSS
            1.1 You’re a front-end developer
            1.2 CSS overview and history
            1.3 Sample site setup
            1.4 Start stylin’
            1.5 CSS selectors
        2 The style of style
            2.1 Naming things
            2.2 When and why
            2.3 Priority and specificity
            2.4 How to be a good styling citizen
        3 CSS values: color and sizing
            3.1 CSS color
            3.2 Introduction to sizing
            3.3 Pixels (and their less-used cousin, the point)
            3.4 Percentages
            3.5 em
            3.6 rem isn’t just for dreaming
            3.7 vw, vh: The new kids on the block
            3.8 Pleasing fonts and line height
        4 The box model
            4.1 Inline vs. block
            4.2 Margins, padding, and borders
            4.3 Floats
            4.4 A little more about the overflow style
            4.5 Inline block
            4.6 Margins for boxes
            4.7 Padding… not just for chairs
            4.8 Fun with borders
        5 Laying it all out
            5.1 Layout Basics
            5.2 Jekyll
            5.3 Layouts, includes, and pages (oh my!)
            5.4 The layout file
            5.5 CSS file and reset
            5.6 Includes intro: head and header
            5.7 Advanced selectors
            5.8 Positioning
            5.9 Fixed header
            5.10 A footer, and includes in includes
        6 Page templates and frontmatter
            6.1 Template content
            6.2 There’s no place like home
            6.3 More advanced selectors
            6.4 Other pages, other folders
        7 Specialty page layouts with flexbox
            7.1 Having content fill a container
            7.2 Vertical flex centering
            7.3 Flexbox style options and shorthand
            7.4 Three-column page layout
            7.5 A gallery stub
        8 Adding a blog
            8.1 Adding blog posts
            8.2 Blog index content loop
            8.3 A blog post page
        9 Mobile media queries
            9.1 How to see in mobile (without looking at your phone)
            9.2 Getting started with mobile designs
            9.3 Mobile viewport
            9.4 Dropdown menu
            9.5 Mobile dropdown menu
        10 Adding more little touches
            10.1 Custom fonts
            10.2 Favicons
            10.3 Custom title and meta description

    Split Pages View

Cover web
Learn Enough CSS & Layout to Be Dangerous
Lee Donahoe and Michael Hartl

An introduction to CSS and page layout, including static site generation with Jekyll
$19.00
Buy eBook
Mailing List All Access Subscription
Follow author to receive email updates about new content
About the authors

Lee Donahoe and Michael Hartl are cofounders (with Nick Merwin) of LearnEnough.com, a leader in the movement to teach the world technical sophistication.

Learn Enough cofounder Lee Donahoe is an entrepreneur, designer, and front-end developer. In addition to doing the design for Learn Enough, Softcover, and the Ruby on Rails Tutorial, he is also a cofounder and front-end developer for Coveralls, a leading test coverage analysis service, and is tech cofounder of Buck Mason, a men’s clothing company once featured on ABC’s Shark Tank. Lee is a graduate of USC, where he majored in Economics and studied Interactive Multimedia & Technologies.

Learn Enough cofounder Michael Hartl is a programmer, author, and entrepreneur. He is the creator of the Ruby on Rails Tutorial, one of the leading introductions to web development, and is the principal author of most of the Learn Enough introductory sequence. He is a graduate of Harvard College, has a Ph.D. in Physics from Caltech, and is an alumnus of the Y Combinator entrepreneur program.

Note: The online version of this tutorial is available for free, and the ebook is available for purchase here.
1 Introduction to CSS

Welcome to Learn Enough CSS & Layout to Be Dangerous!

CSS—short for Cascading Style Sheets—is the styling language of the World Wide Web. CSS lets developers and designers define what a web page looks like and how it behaves, including how elements are positioned in the browser. Every website that you visit (with some incredibly rare exceptions) uses CSS to make the user experience and interface look inviting, which means that learning the basics of CSS is an essential part of becoming a web developer or designer. It’s also useful for anyone who interacts with developers and designers, which these days seems like practically everyone.

Most CSS tutorials teach the subject in isolation, showing you how to make individual changes to things like text color or font size, without showing you how to put everything together as an integrated whole. This approach is a lot like trying to teach a foreign language by having students read the dictionary. You might learn lots of words, but you would end up with little to no context or ability to have a real conversation (Figure 1).1

In contrast, Learn Enough CSS & Layout to Be Dangerous is specifically designed to show you how CSS works in the context of a real website.
images/figures/spanish
Figure 1: You’re not going to learn Spanish from the dictionary alone.

It’s especially hard to find tutorials that cover how to develop the layout of the page—that is, how one positions elements on the page and determines what content goes where. It’s because this subject is so important—and yet so neglected—that we called this tutorial Learn Enough CSS & Layout to Be Dangerous, rather than simply Learn Enough CSS to Be Dangerous.

Why is layout so often ignored? It’s partially because the layout aspects of CSS can be rather complicated, but it’s also because doing layout right calls for more than plain HTML and CSS. Making a real, industrial-grade website requires using a templating system to assemble the various parts—there are simply too many repeated and custom elements (such as headers, footers, dynamically generated names and dates, etc.) to build such sites by hand (Figure 2).
images/figures/page
Figure 2: Most modern websites have many repeated and custom elements.

As a result, even learning enough CSS to be dangerous—that is, enough to accomplish your goals without taking the time to become a complete expert—is far more extensive than most people realize. You need to learn not only the basic CSS rules, but also more advanced rules governing page layout, together with a tool to assemble all the parts into a combined whole.

Learn Enough CSS & Layout to Be Dangerous is designed to fill this need. It fits into the Learn Enough introductory sequence immediately after Learn Enough HTML to Be Dangerous, but it’s also suitable for more experienced developers who want to strengthen their knowledge of web design.2 Among other things, this means that Learn Enough CSS & Layout to Be Dangerous is both a possible prerequisite and also an excellent follow-on to the Ruby on Rails Tutorial.

As a result of building on the ideas developed in previous Learn Enough tutorials (Box 1), Learn Enough CSS & Layout to Be Dangerous is also unusual in that we will be deploying our sample CSS site to the live Web, all while following professional-grade development practices. Because of this integrated approach, Learn Enough CSS & Layout to Be Dangerous puts everything together in a way you probably haven’t seen before, even if you’ve previously studied CSS.
Box 1. Prerequisites.

This tutorial assumes that you know how to use a Unix command line, are comfortable using a text editor, are familiar with using Git for version control, and understand the basic structure of an HTML page. If you’d like an introduction or a refresher on any of these subjects, we suggest reading one or more of the corresponding Learn Enough tutorials (all of which are available for free online, and are available with videos via a subscription to the Learn Enough Society):

    Learn Enough Command Line to Be Dangerous
    Learn Enough Text Editor to Be Dangerous
    Learn Enough Git to Be Dangerous
    Learn Enough HTML to Be Dangerous 

You’ll also probably find it helpful to set up your computer as a proper development environment, as covered in Learn Enough Dev Environment to Be Dangerous, although this step can be deferred until Chapter 5.
1.1 You’re a front-end developer

CSS isn’t the kind of language that’s useful to learn in little half-steps—the part that people find difficult is dealing with handling styling when you are deep into creating an honest-to-goodness website with many levels of complexity. The real skill comes in knowing how to plan for a multi-page site that uses a bunch of different snippets of code3 placed into a flexible layout that organizes content and data in a useful way.

There are already many sites (like the Mozilla Developer Network CSS Reference) that exhaustively document every CSS property, so going over each and every option from the specification would just be a duplication of effort. Instead, Learn Enough CSS & Layout to Be Dangerous is designed to complement such reference works by showing you how CSS applies to the design of a real website. The resulting narrative explanation gives you the context necessary to understand and apply CSS documentation—especially when combined with a little technical sophistication (Box 2).
Box 2. Technical sophistication

One of the principal themes of the Learn Enough tutorials is the development of technical sophistication, the ability to figure out and solve technical problems.

This tutorial includes many opportunities to apply technical sophistication. For example, many of the code listings require you to orient yourself in a CSS file and figure out where to put the new style rules introduced by the listing. Another important technique is learning to comment out CSS rules and then refreshing the browser to see what they do. We’ll also occasionally add CSS rules that are purely for demonstration purposes; technical sophistication is the skill you need to figure out that such demo code can safely be deleted, especially if a future listing omits it.

Later chapters, particularly after Chapter 5, also require that you successfully configure a development environment and run a templating system to build a professional-grade website. A huge number of things can go wrong when getting these to work; if you get stuck, there’s no substitute for Googling around and determination—both of which are key aspects of technical sophistication.

The important thing at this point in your progress as a developer is to start learning how styling and layout concepts work together, how HTML and CSS combine to make a layout that is actually useful, and how to use some sort of system that allows you to avoid repeating sections of the site or styling on multiple pages (Box 3). Doing otherwise would make you an expert at changing text color and size, but you’d have no chance of applying the knowledge you’ve gained to a real-world scenario. In fact, by learning CSS in a holistic way, you’ll not just be getting an introduction to styling—this tutorial is also going to be your first introduction to the world of front-end development (Figure 3).4
images/figures/owl
Figure 3: Yer a wizard front-end developer, Harry.
Box 3. Staying DRY

If you’ve been poking around the Internet in places where developers talk shop, you might have noticed someone mention staying DRY, with “dry” in all caps. They aren’t talking about relative moisture levels. What they are talking about is a core principle in programming: Don’t Repeat Yourself.

The idea behind DRY is that good coding should include as few instances of unnecessary repetition as humanly possible, simply because you have the same code in a bunch of places, then every time you want to make a change you’ll have to update all the different spots in the application where that code is repeated. For example, if you wanted to change a link to the navigation bar of a hand-built site, you’d have to make the same change on every page. On a two-page site this wouldn’t be a big deal, but for a bigger website it would be a nightmare.

Programmers are a special sort of lazy—especially when it comes to doing something repetitive that could be done more efficiently with a little bit of extra programming. To make it easier to be lazy, enterprising programmers spend countless hours creating systems that allow other developers not to have to repeat themselves. We all benefit from developers who at some point decided they were going to work really hard now so they could work less hard in the future.

Templating software, like the system we will be using in Chapter 5, allows us not to repeat ourselves by collecting repeated code into individual files, and then including these code snippets onto any page where they’re needed.

The result is that we can write something like the navigation menu for a site once, put it in its own little file, and then include that file every place where the navigation needs to appear. If we want to change the navigation later on, we need to edit only that single file, and the changes will automatically be applied to every page that includes it. We’ll learn how to do this in Section 5.6.
So, what is front-end development?

When someone says that they are a front-end developer, that means that they work on the parts of a site that people see and interact with. That includes things like HTML, CSS, and JavaScript. You’ll also hear people talk about user interface (UI) design (the way things look) and user experience (UX) design (the way that the interface and different pages function to move users through the site to a goal).

The complement to front-end development is back-end development, which involves the architecture of data, how it is stored, and how it is delivered. Later Learn Enough tutorials (starting with Learn Enough Ruby to Be Dangerous) cover the basics of back-end development, culminating in the Ruby on Rails Tutorial, which teaches how to develop a full web application with a database, users, login and authentication, and more.

So, how do we turn an HTML caterpillar into a front-end developer butterfly (Figure 4)?
images/figures/butterfly
Figure 4: It’s a whole lot easier to read Learn Enough CSS & Layout to Be Dangerous than to pupate.

We’ll start by building on the styling introduced in Learn Enough HTML to Be Dangerous. In the final sections of that tutorial, we showed how to add styling directly to elements on a page, while also noting that such inline styling isn’t the best way to go in practice. In this tutorial, we’ll discuss the method that is the best practice, namely, CSS.

Throughout the rest of this chapter, we’ll learn the basics of CSS declarations and values by starting with a few super-simple elements on a sample page, with a particular focus on applying the DRY principle (Box 3). We’ll end with a first introduction to the essential technique of CSS selectors to target particular page elements for styling.

In Chapter 2, we’ll discuss aspects of selectors that are important to get right at the beginning of a project, with a focus on managing complexity and maintaining flexibility by choosing good names for things (including an introduction to CSS color conventions).

Chapter 3 introduces two of the most important kinds of CSS values: colors and sizes. These lay an essential foundation for Chapter 4 on the box model, which determines how different elements fit together on the page.

In Chapter 5 and Chapter 6, we’ll take the page that we’ve been working on and factor it into a layout using a templating system called Jekyll to build professional-grade websites that are easy to maintain and update.

In Chapter 7, we’ll learn how to make flexible page layouts using flexbox, adding layouts for a photo gallery page (to be filled in in Learn Enough JavaScript to Be Dangerous) and a blog with posts. In Chapter 8, we’ll add the blog itself, showing how to use Jekyll to make a professional-grade blog without black-box solutions like Wordpress or Tumblr.

Because a large and growing amount of web traffic comes from mobile devices, in Chapter 9 we’ll cover the basics of using CSS and media queries to make mobile-friendly sites without violating the DRY principle (Box 3).

Finally, in Chapter 10 we’ll add the kinds of little details (like custom fonts and meta tags) that make a site feel complete. The result will be an industrial-strength, nicely styled site deployed to the live Web.

Let’s go!
1.2 CSS overview and history

CSS takes the form of plain text declarations inserted into an HTML or CSS file using a text editor. A typical series of CSS declarations might look like Listing 1. (You are not expected to understand these styles at this point.)
Listing 1: Typical CSS declarations.

body {
  color: black;
}

p {
  font-size: 1em;
}

p.highlighted {
  font-size: 1.5em
  background: yellow;
}

The “Cascading” part of Cascading Style Sheets refers to the way the defined styles flow, or “cascade”, down from element to element on a page based on a few factors like which declaration came first, whether an element is the child of a parent element that has styles applied to it, or the strength of the declaration (more on this in Section 2.3). This inheritance of style (from the top levels to elements below) happens so that we as developers can avoid having to define how every single element should look. For example, if we changed the color in the body tag in Listing 1, that change would cascade down and change the color attribute on every interior element as well.

The “Style Sheet” part of the name (sometimes written as the single word stylesheet) refers to how CSS allows developers collect all the style declarations in a separate section of the page (called an internal stylesheet), or place them into an external file (called, you guessed it, an external stylesheet). External stylesheets are loaded onto the page as a link in the head section of the HTML. (We’ll learn how to do this ourselves in Chapter 5.) The result is that we end up separating the code that defines how something looks (or is positioned) from the actual content—all of which makes for simpler and more maintainable code.
CSS always be changing

One important thing to note about CSS is that, like HTML, it’s constantly evolving to better serve the needs of web designers and developers. In fact, in many ways CSS is evolving even faster than HTML (Figure 5).5
images/figures/goldblum
Figure 5: CSS… uh, finds a way.

Even though future additions are added to the official CSS specification all the time, they aren’t evenly distributed—when new additions to CSS are proposed, the adoption of those new concepts happens on a browser-by-browser basis. A style that might work in Google Chrome might be totally unsupported by Mozilla Firefox or Microsoft Internet Explorer (or IE’s latest incarnation, Microsoft Edge). Or it’s possible that a given style might be supported, but only if you use a special temporary name to declare the style, a feature that lets developers target only the browsers that support the style they want to use (Box 4).
Box 4. Vendor Prefixing

Because it takes a while for an addition to the language to go from a suggested new specification (or spec) to an officially included part of CSS, new features aren’t accepted by all browsers at the same time. Most browser makers aren’t interested in waiting around for the spec to be officially updated, though—they want their software to push the envelope and do really cool stuff. So vendors take these CSS spec proposals and implement their own versions of the spec.

To get around the potential confusion that could happen if things work differently from browser to browser, the browser vendors typically add a prefix to the experimental styles, such as -webkit-, -moz-, and -ms- (respectively for WebKit, Mozilla, and Microsoft browsers). This allows the applied style to target specific browsers in case the support differs.

For instance, the CSS transition declaration (covered in Section 7.4) was implemented in most browsers before it was a part of the official spec, and to use it you would have needed to declare the styling like the following examples with vendor prefixes:

  -webkit-transition: all 0.1s linear;
  -moz-transition: all 0.1s linear;
  -ms-transition: all 0.1s linear;
  transition: all 0.1s linear;

The first rule here specifically targets browsers that use the WebKit layout engine (which includes Safari and Chrome), while the second targets browsers using Mozilla’s Gecko engine (principally Firefox), and the third targets Microsoft browsers (Internet Explorer and Edge). Finally, the fourth rule is an unprefixed declaration—in this case, just transition by itself—which is included so that when support becomes official we won’t have to go back into our code and add it in. (The transition style is supported by all major browsers today, so if you see the prefixed versions in code that you are working on, you can safely delete them.)

Luckily, at this point the most common styling definitions are essentially the same across different browsers,6 and we aren’t going to cover anything in this tutorial that has questionable browser support. At some point, though, you’ll probably find yourself wanting to use a more cutting-edge style, and when that happens we recommend using a tool like CanIUse to figure out how well-supported the style is. Don’t ever feel self-conscious about using reference sites like that—the fast-changing nature of the language and the spotty browser support make it a necessary tool even for people who have been doing this for years.
How did CSS develop?

In the beginning, content on the Internet was simply plain text. Then, as methods for organizing content started to come into existence (such as HTML around 1990), a number of methods sprang up to affect the appearance and layout of the data.

At first, many styling solutions that affected how the page looked would be set by individual users’ browser preferences rather than by the creator of the page. As the complexity of the web increased, it became increasingly obvious that there should be a way for the owner of a site to at least suggest how a page should look, rather than leaving the appearance up to each individual browser.

Lots of interesting suggestions were put forward that never got widely adopted, usually because the proposed styling was overly complicated or used a totally non-intuitive structure.

    Robert Raisch developed RRP, which used arcane two-character style declarations and was fairly unreadable.
    Pei-Yuan Wei created the ViolaWWW browser and a styling system called PWP, which introduced nesting styles and external stylesheets, but it was only released for Unix operating systems and never really caught on.
    FOSI was created for an HTML precursor called SGML, and it worked by adding complicated tags on the page around content (not good).
    DSSSL allowed for complex declarations and was more of a programming language with styling attached, but it had a complicated syntax that made it overly complex for styling. 

In short, there was a real Cambrian Explosion of proposed standards to make the web pretty, and while some of these systems ended up contributing elements to what became CSS, none of them are direct ancestors (Figure 6).7
images/figures/cambrian
Figure 6: There were a lot of precursors to CSS… not all of them successful.

About five years after the introduction of HTML, Håkon Lie (working with Bert Bos) put forward a styling system proposal in December of 1996 called CHSS (Cascading HTML Style Sheets). As you might expect, the original proposal has some details that are no longer present in the language, but in his doctoral thesis Håkon Lie simplified the specification into something that more closely resembles modern CSS. Eventually, the concept was adopted by the World Wide Web Consortium (W3C) as the system for styling web content.

Although it represented a big step forward, creating a specification is only half the battle—browsers have to support the standard for it to be of any use to end-user. No browser even partially supported CSS until 1997, and there wasn’t full support of the standard in any one browser until March of 2000 (Figure 7)8—partially because browser makers still had their own ideas for how to accomplish styling, and partially because many browsers supported non-standard HTML tags (we’re looking at you, Internet Explorer…).
images/figures/2000
Figure 7: After the party for the new millennium… we got CSS. Hooray?

Each browser handled CSS in its own idiosyncratic way for a long time, and anyone who has been working in front-end development for a while can tell you how maddeningly difficult it was to style a website so that it looked the same across browsers. Microsoft’s Internet Explorer was by far the biggest problem (Figure 8) and we can only imagine the number of people who gave up on the world of web design and development thanks to horrific CSS support in early versions of IE.9
images/figures/ie6
Figure 8: You can’t fully understand hate until you try to design for IE6.

The differences between implementations of CSS in different browsers remained significant until just a few years ago, with the rise to dominance of the WebKit browsers (Google Chrome and Apple Safari) and Gecko-powered Mozilla Firefox. So when reading this tutorial, just keep in mind that styling the web was a complete and utter mess until very recently—about 15 years after the initial release of the CSS spec in 1997.
The bog of eternal subjectivity

One last bit of meta-information before we jump in and start styling: deciding how to actually implement CSS on a given page can be a confusing mess. Whereas the previous Learn Enough tutorials (Box 1) were a little more prescriptive in nature, with many cases where there was only one right way to do things, we are now going to be venturing into places where there is often no right answer. When designing websites with CSS, many solutions to a problem typically exist, which means subjective judgment is the rule rather than the exception (Figure 9).10

Helping you navigate this mess is where we come in.
images/figures/bog-of-subjectivity
Figure 9: Smell baaaad!

Oh, and to make this all a little more fun, you may recall from Box 4 that every browser implements some parts of the CSS standard in its own slightly different manner, so you can never be absolutely certain that something will look the same to different users if they are using different browsers… to say nothing of how something will look on different screen sizes and resolutions for different operating systems (Chapter 9).

You have to get used to the idea that no site is going to be exactly the same when viewed by different people. You’ll learn to design (or implement other people’s designs) in a way that allows room for CSS’s inherent ambiguity. Unlike the tightly constrained world of print design, getting things to look exactly the same in every browser and on every operating system is just something you have to give up worrying about.

Additionally, when talking about which CSS rules to use when styling a site or creating a layout, best practices tend to move in fads, or are influenced by the subjective opinion of the developers who worked on a project before you. For example, as discussed in Section 1.5, elements on the page frequently need to be assigned classes or ids, and the way that names are picked is entirely up to the person writing the code. As you might guess (if you know many developers or designers), people have lots of strong opinions on how you should be naming things—a classic holy war situation (Figure 10).11
images/figures/holywar1
Figure 10: HOLY WAAAAAAARS!

The most important thing is to be consistent. If you start a project and do things one way, make sure to keep following the same conventions for the life of the project. Or, if you decide to make a drastic change, spend the next couple of days updating all your old code, for the sake of future developers (including yourself). Keep an eye out in this tutorial for “Style Note” boxes that have tips on what the current best practices are for different uses of CSS.
1.3 Sample site setup

Now that we’ve got an overview of the purpose and origins of CSS, it’s time to start looking at some concrete examples. The initial styling rules will necessarily be simple, so it’s important to have patience while we lay this crucial foundation for the working website (with layout) that we’ll be developing starting in Chapter 5.

We’ll start by creating a new project in the repos folder using the same basic mkdir command covered in Learn Enough HTML to Be Dangerous (Listing 2).
Listing 2: Adding the folder for our sample project.

$ cd                                   # cd to the home directory
$ mkdir -p repos/<username>.github.io  # Make site directory
$ cd repos/<username>.github.io        # cd into new directory

Note that we’ve used a special directory name that corresponds to the main GitHub Pages site for your account:12

<username>.github.io

In Listing 2, <username> should be replaced with your GitHub username, so the full URL should look something like mhartl.github.io.

To get our site started, we’ll also create an index.html file using the touch command (as discussed in Learn Enough HTML to Be Dangerous), as shown in Listing 3.
Listing 3: Adding a blank index.html.

$ touch index.html    # Create an empty index file

Inside the new folder, use your favorite text editor to open the newly created index.html file and paste in the markup shown in Listing 4. You should recognize this as a very basic HTML page—if this doesn’t look familiar at all, we recommend reviewing Learn Enough HTML to Be Dangerous at this time.
Listing 4: The initial HTML for our site.
index.html

<!DOCTYPE html>
<html>
  <head>
    <title>Test Page: Don't Panic</title>
    <meta charset="utf-8">
  </head>
  <body>
    <h1>I'm an h1</h1>
    <ul>
      <li>
        <a href="http://example.com/" style="color: red;">Link</a>
      </li>
      <li>
        <a href="http://example.com/" style="color: red;">Link</a>
      </li>
      <li>
        <a href="http://example.com/" style="color: red;">Link</a>
      </li>
    </ul>
    <h2>I'm an h2</h2>
    <div style="border: 1px solid black;">
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
    <div style="border: 1px solid black;">
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
    <div style="border: 1px solid black;">
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
    <div style="border: 1px solid black;">
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
  </body>
</html>

When you open that HTML document in your browser (Box 5), you’ll see a series of three red links, some headers, and a series of green links in boxes (Figure 11). This will be our initial test page.

Note: Due to various slight differences between browsers, browser window sizes, etc., your results may not always match the screenshots exactly, so small discrepancies are not a cause for concern. As we’ll emphasize throughout this tutorial, it’s important to focus on achieving good-enough results without chasing the unreachable goal of pixel-perfection.
images/figures/index-start
Figure 11: This is the beginning of something great, unassuming though it may seem.
Box 5. Opening HTML files

Depending on your exact setup, there are several ways you might open the HTML file shown in Listing 4. The most straightforward way at this stage is to use your native system, which is the main method discussed in Learn Enough HTML to Be Dangerous. On macOS, our favorite way to do this is with the open command, which opens the file using whatever the default program is for that file (e.g., for an HTML file it might use Safari or Chrome, for a PDF it might use Preview, etc.):

  $ open index.html        # macOS only

The similar xdg-open command works on many Linux systems:

  $ xdg-open index.html    # Linux only

You should be aware that using your native system will likely prove increasingly challenging as this tutorial progresses. The reason is that, Jekyll, the static site builder we’ll be using starting in Section 5.2, requires setting up your native system as a proper development environment, equipped with programming languages and other software needed to develop websites and dynamic web applications.

Our bet is that, if you’re reading this tutorial, you’re up to the challenge. This means taking the time to follow the steps in Learn Enough Dev Environment to Be Dangerous for your native system (either now or in Chapter 5).

There is one catch with might apply to some readers: there’s no great solution if you’re using Microsoft Windows. Indeed, one perennial challenge when teaching good development practices is the general difficulty of developing programs on Windows operating systems. As described in Learn Enough Dev Environment to Be Dangerous, for Windows users we recommend using either a cloud IDE or a Linux virtual machine. (In fact, the two cases are fundamentally the same, as the cloud IDE we recommend, Cloud9, runs Linux.)

The cloud IDE offers an especially convenient choice for getting up and running quickly, though one downside is that you need to be online to use it. If you do end up using the cloud IDE, opening an HTML file is as simple as clicking “Run” and then clicking the resulting URL to open it (Figure 12). (There are actually a couple of other methods that also work. Figuring out this sort of thing on your own is a perfect example of technical sophistication (Box 2).)

Eventually, though, it’s a good idea to master your native system (especially if that system is Unix-based, e.g., macOS or Linux). Now’s an excellent time to take that step.
images/figures/open_html_cloud9
Figure 12: Opening an HTML file using the cloud IDE.

As in Learn Enough Git to Be Dangerous and Learn Enough HTML to Be Dangerous, we’ll deploy our new website immediately to production, which is a good habit to cultivate. First, you’ll need to create a new project at GitHub, using the steps shown in Learn Enough HTML to Be Dangerous, which in this case looks like Figure 13.
images/figures/new_repo
Figure 13: Creating a new GitHub repo.

Once you’ve finished the steps needed to create the repository, initialize and deploy it using the commands shown in Listing 5.
Listing 5: Deploying the initial site to GitHub pages.

$ git init
$ git add -A
$ git commit -m "Initialize repo"
$ git remote add origin <repo url>
$ git push -u origin master
$ git checkout -b gh-pages
$ git push -u origin gh-pages

If you find the sequence of commands in Listing 5 challenging instead of familiar, it’s probably a good idea to review Learn Enough Git to Be Dangerous and Starting the project from Learn Enough HTML to Be Dangerous. (Confirming that the deployment succeeded is left as an exercise (Section 1.3.1).)

Although we’ll add in the occasional Git commit/deployment in this tutorial, in general these will be up to you. Having learned the material in Learn Enough Git to Be Dangerous and Learn Enough HTML to Be Dangerous (or already being familiar with it), now is a good time to practice making such decisions on your own.
Exercises

    By visiting the URL <username>.github.io/index.html, confirm that the deployment to GitHub Pages succeeded. Is it necessary in include index.html in the URL? 

1.4 Start stylin’

As discussed in Section 1.2, CSS is a way of defining how elements on an HTML page look and are positioned, with styling that flows (“cascades”) down from element to element based on factors like which declaration came first, whether an element is the child of a parent element that has styles applied to it, or the specificity of the declaration.

So what do “parent”, “children”, and “specificity” mean in the context of a web page and how it gets styled?

The idea is that every element on the page is contained inside of another element, which in turn can contain other elements—like Russian nesting dolls (Figure 14).13
images/figures/russian_dolls
Figure 14: Russian dolls are designed to nest one inside the other.

We can visualize the parent and child structure of the elements on a typical page using the diagram in Figure 15.
images/figures/parent-child
Figure 15: Relationships always cascade down.

The hierarchical tag structure shown in Figure 15 is known as the Document Object Model, or DOM for short.14 Each new level in the DOM is a child of the level above it. In other words, the html tag is the parent of the entire page, the body tag is a child of the html tag, and so on. The body tag then has its own children, which are the h1 and h2 elements, the unordered list ul, and the div elements. In CSS, styling rules flow down from parents to children unless another style interrupts and takes priority.

You’ll notice that there are a bunch of repeated inline styles in our example page (Listing 6).15
Listing 6: Repeated inline styles violate the DRY principle.
index.html

.
.
.
<div style="border: 1px solid black;">
<div style="border: 1px solid black;">
<div style="border: 1px solid black;">
.
.
.

Now that you know about the DRY principle (Box 3), all that redundant styling should be causing a mild case of programmer’s itch, and the only cure is to eliminate the duplication. The technique we’ll use is called refactoring, which involves changing the form of the code without changing its function. In other words, after making the changes in this section, the appearance in the browser should remain the same.

To make the example code cleaner, we are going to use a method mentioned in Section 1.2: an internal style sheet. To implement this, we need to use a new HTML element, the style tag (Listing 7). This style block will hold all our style declarations, but by design the style tag isn’t visible on rendered pages, and thus won’t be visible in a user’s browser.
Listing 7: The initial empty style block for our page.
index.html

<!DOCTYPE html>
<html>
  <head>
    <title>Test Page: Don't Panic</title>
    <meta charset="utf-8">
    <style>

    </style>
  </head>
  .
  .
  .

A style block like this can actually be placed anywhere on the page, but the conventional placement is inside the page’s head tag. (The best practice is actually to put the CSS rules in a separate file, a task we’ll undertake in Section 5.5.)

Now let’s get rid of the repetition in Listing 6 by adding in our first CSS declaration, as shown in Listing 8.16
Listing 8: Adding our first CSS style.
index.html

<!DOCTYPE html>
<html>
  <head>
    <title>Test Page: Don't Panic</title>
    <meta charset="utf-8">
    <style>
      div {
        border: 1px solid black;
      }
    </style>
  </head>
  .
  .
  .

Figure 16 shows the anatomy of the CSS rule from Listing 8: the div part of the statement, which is outside the curly braces, is called the CSS selector (in this case targeting only div HTML elements). Then there is a declaration made of up a property (border) and a value (1px solid black) separated from the property by a colon. Finally, there is a semicolon at the end of the line that ends the style. (Just a warning: a lot of these terms get mixed up in regular usage. For example, people will sometimes refer to the whole thing, including the selector, as the declaration.)
images/figures/names
Figure 16: What’s in a name?

Although the spacing shown in Listing 8 is typical, CSS is similar to HTML in that whitespace is ignored by the browser. For the sake of any humans viewing your markup, though, it’s a good idea to follow certain formatting conventions (Box 6).
Box 6. Style Note: Formatting styles

The styling statement from Listing 8 can also be written with everything on one line, like this:

  div {border: 1px solid black;}

While that might look nice and tidy at first, you should probably avoid writing CSS that way, as it would make for unreadable code as you start to add more styles. It is far easier to read a list of style declarations like this:

  button {
    background-color: gray;
    border: 1px solid black;
    color: white;
    cursor: pointer;
    display: inline-block;
    font-family: "proxima-nova", "Proxima Nova",
                 sans-serif;
    font-size: 12px;
    font-weight: bold;
    letter-spacing: 0.15em;
    padding: 10px 15px;
    text-decoration: none;
    text-transform: uppercase;
    transition: all 0.1s linear;
  }

than it is to read this:

  button { background-color: gray; border: 1px solid
  black; color: white; cursor: pointer; display:
  inline-block; font-family: "proxima-nova",
  "Proxima Nova",
  sans-serif; font-size: 12px; font-weight: bold;
  letter-spacing: 0.15em; padding: 10px 15px;
  text-decoration: none; text-transform: uppercase;
  transition: all 0.1s linear;}

Now just imagine trying to find specific properties on a page with hundreds of styles where every declaration looks like that… “Nightmare” wouldn’t even begin to describe your development experience.

A second point about formatting is that you’ll notice that the style properties are all in alphabetical order. It might seem annoying to keep your properties alphabetized, but if you do you’ll find that over time you will find things much faster than if the ordering is haphazard. Fortunately, your text editor of choice likely has an alphabetize feature. For example, in Sublime Text you can select multiple lines and hit F5 to automatically rearrange things in alphabetic order! Other editors frequently have packages that do the same.

After adding the CSS in Listing 8, delete all the style="border: 1px solid black;" attributes from the four div tags. Your test page’s code should now look like Listing 9.
Listing 9: How the entire page should now look.
index.html

<!DOCTYPE html>
<html>
  <head>
    <title>Test Page: Don't Panic</title>
    <meta charset="utf-8">
    <style>
      div {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <h1>I'm an h1</h1>
    <ul>
      <li>
        <a href="http://example.com/" style="color: red;">Link</a>
      </li>
      <li>
        <a href="http://example.com/" style="color: red;">Link</a>
      </li>
      <li>
        <a href="http://example.com/" style="color: red;">Link</a>
      </li>
    </ul>
    <h2>I'm an h2</h2>
    <div>
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
    <div>
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
    <div>
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
    <div>
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
  </body>
</html>

Save the changes, refresh the page in your browser… and BAM! Everything should look the same. (If not, double-check your work to see if you can get your results to match.)

So what happened here? The declaration that we added in Listing 8 is a CSS statement that tells the browser it needs to apply a 1-pixel wide solid black border to all of the divs in the body of the html. (We’ll learn more about pixels in Section 3.3.) The result is a simplification of the code without any change in the page’s appearance.

Now that we’ve seen how to consolidate a bunch of inline styles into a single CSS declaration, let’s do the same thing for the links that are colored red via inline styles inside of the lis. Your new sample page should look like Listing 10.
Listing 10: Removing the red link colors from the HTML.
index.html

<!DOCTYPE html>
<html>
  <head>
    <title>Test Page: Don't Panic</title>
    <meta charset="utf-8">
    <style>
      a {
        color: red;
      }
      div {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <h1>I'm an h1</h1>
    <ul>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
    </ul>
    <h2>I'm an h2</h2>
    <div>
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
    <div>
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
    <div>
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
    <div>
      <a href="http://example.com/" style="color: green;">I'm a link</a>
    </div>
  </body>
</html>

As before, the appearance shouldn’t change after refreshing the browser.

At this point, we’ve definitely made progress in the fight against inline style redundancy, but what about those links that are colored green at the bottom using inline styling? One way to clean up the inline styles would be to use CSS classes, which we’ll start covering in Section 1.5, but for now let’s see if we can do it with just generic CSS selectors.

Because the links in question are contained inside of divs, and the other links on the page are not, we can use the nesting inheritance of CSS to define a style that changes only the color of links inside of divs. We can accomplish this by adding the declaration from Listing 11 to the style block, and then remove the inline styles from the links on the page.
Listing 11: Creating a style that targets links inside of divs.
index.html

div a {
  color: green;
}

Your entire test page should now look like Listing 12.
Listing 12: Whole page with new styling to target links inside divs.
index.html

<!DOCTYPE html>
<html>
  <head>
    <title>Test Page: Don't Panic</title>
    <meta charset="utf-8">
    <style>
      a {
        color: red;
      }
      div {
        border: 1px solid black;
      }
      div a {
        color: green;
      }
    </style>
  </head>
  <body>
    <h1>I'm an h1</h1>
    <ul>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
    </ul>
    <h2>I'm an h2</h2>
    <div>
      <a href="http://example.com/">I'm a link</a>
    </div>
    <div>
      <a href="http://example.com/">I'm a link</a>
    </div>
    <div>
      <a href="http://example.com/">I'm a link</a>
    </div>
    <div>
      <a href="http://example.com/">I'm a link</a>
    </div>
  </body>
</html>

The page is a lot cleaner now, isn’t it? Separating the styling from the content makes the page’s code much easier to read, but maybe you can already see the problem with the way that we’ve targeted the styles…

The problem is: if we were to add new divs anywhere on the page, and they happened to have links inside them, those links would be green even if that isn’t what we want. The reason why is that the selector we used in that declaration is way too generic. In Section 1.5, we’ll take a look at how to add styling with far greater specificity using CSS ids and classes.
Exercises

    Using what we learned about targeting links inside of other objects, change the color of the links inside of the lis.
    Add a border around the lis using the same styling as we used to add the borders around the divs. 

1.5 CSS selectors

Between Learn Enough HTML to Be Dangerous and the beginning of this tutorial, we have so far used only rudimentary targeting techniques for styles. In Learn Enough HTML to Be Dangerous, we learned how to add styles directly to elements, but this approach is brittle and inefficient. In this tutorial, so far we’ve used CSS that is separated from the content, but we have used only generic selectors like div or a. The problem with generic element selectors is that they apply to all the elements on the page. So, how can we apply styling to specific elements rather than to every single one?

There are two methods, one that targets only one element per page—the id (or “identification”) selector17—and one able to target multiple elements—the class selector. Let’s edit our example HTML to add this kind of targeting to our page.

Ids and classes are always applied only to the opening tag of an element, and they always have the same format. We’ll use the div tag for concreteness:

<div id="foo" class="bar">
  .
  .
  .
</div>

We see here that both ids and classes consist of key/value pairs, where each value is a string that serves as a label for the id or class. In this case, the key id has value "foo" and the key class has value "bar".

Although CSS offers a great deal of flexibility in choosing id and class names, there are a few restrictions and usage suggestions:

    Use only one id per element.
    No numbers are allowed at the beginning of the name (e.g., name1 is valid, but 1name isn’t).
    Dashes (-), underscores _, and CamelCase can be used to join multiple words (so foo-bar-baz, foo_bar_baz, and FooBarBaz are all valid names).
    Spaces are invalid in id names, and are used to separate multiple names in the case of classes (so id="foo bar" is illegal, while class="foo bar baz" places three separate classes on an element).
    Be consistent (e.g., if using dashes as separators, use them everywhere—don’t mix them with underscores). 

To see how this works in practice, let’s add some ids and classes to our sample page. On the first opening div tag that comes right after the h2, add id="exec-bio", and then add class="bio-box" to all of the divs in that section, as shown in Listing 13).
Listing 13: Adding CSS classes and an id to the sample page.
index.html

<!DOCTYPE html>
<html>
  .
  .
  .
  <body>
    .
    .
    .
    <h2>I'm an h2</h2>
    <div id="exec-bio" class="bio-box">
      <a href="http://example.com/">I'm a link</a>
    </div>
    <div class="bio-box">
      <a href="http://example.com/">I'm a link</a>
    </div>
    <div class="bio-box">
      <a href="http://example.com/">I'm a link</a>
    </div>
    <div class="bio-box">
      <a href="http://example.com/">I'm a link</a>
    </div>
  </body>
</html>

(This use of a class is good CSS practice, but we generally don’t recommend using an id in this context; we include it here mainly for demonstration purposes. We’ll discuss this issue in more detail in Section 2.2.)

Next, let’s update our CSS block to target these new selectors. To target an id in CSS, you put a # (usually read “hash”) in front of the name, and to target a class you add a . (usually read “dot”). For example, to change the background color of the #exec-bio id, we can use the following CSS rule:

#exec-bio {
  background-color: lightgray;
}

(Here lightgray represents (surprise!) a light gray,18 which is an example of a CSS color name. We’ll cover the details of color naming in Section 3.1.) Similarly, to apply a rule to the .bio-box class,19 we can use the following CSS:

.bio-box {
  border: 1px solid black;
}

As we’ll see in a moment, this rule keeps the thin black border added in Listing 9, but in such a way that it doesn’t apply to all the divs on the site.

Finally, we can target the anchor tags inside the bio boxes using the combination of the class name and the tag name, like this:

.bio-box a {
  color: green;
}

This turns the a tags green, but only if they’re inside an element with class "bio-box". This class-based approach gives us much finer-grained control than the method used in Listing 11.

Adding these three rules to the style block (while removing the rules we no longer need) leads to the markup shown in Listing 14.
Listing 14: Adding CSS rules to target the classes and id.
index.html

<

After saving your changes and refreshing the browser, you should see that the boxes at the bottom have the same border as before, but now the one with the CSS id now has a light gray background (Figure 17).
images/figures/selectors
Figure 17: Elements targeted with classes and ids.

Congrats! You’ve just used ids and classes to target styles at specific elements, and have leveled up your CSS knowledge. Now that you’ve learned how to make declarations, and how to use ids and classes, we can now start getting into the nitty gritty of how CSS works.
Exercises

    Try adding a new CSS id to the style section (you pick the name) that sets the background color of an element to orange, and then add that id to one of the links on the page.
    Add a new class to the style section (you pick the name again) that changes the background color to azure, and add that class name as a second class on the .bio-boxes. You’ll notice that one box is different from the rest, something that we’ll discuss in Section 2.3.
    Commit your changes from this chapter and deploy the result to GitHub Pages. 

2 The style of style

We can think of CSS as operating at two main levels: the browser and the text editor. From the browser’s perspective, the exact choices for CSS classes and ids is irrelevant; indeed, as far as the browser is concerned, there is hardly any difference between beautiful self-contained CSS with perfectly comprehensible class names and horrible inline styles on every element.20

At the level of the text editor, though, these concerns matter a lot to the people writing the HTML and CSS for the site—in this case, us. The browser might not care much about the repetition and complexity from inline styles and poorly named classes, but we sure do.

Moreover, bad styling choices can haunt us throughout a project, so it’s important to do our best to get them right from the start (bearing in mind that we might have to make some changes down the line).

In this chapter, we’ll focus on developing an understanding of the “style of style”—how to make good choices in naming and structuring the various parts of our site—as early as possible. The result will be a codebase that is flexible and maintainable, both for us and for any other developers who need to modify the site later on.
2.1 Naming things

As computer scientist Phil Carlton once remarked, “There are only two hard things in Computer Science: cache invalidation and naming things.” This latter “hard thing” applies to front-end development as well.

When coming up with names for classes and ids, it’s often helpful to think in terms of how something functions or what its intent is, and it’s usually best to be specific. For example, making a class called "box1" is a bad idea because the name is so generic; on a big project, you might not remember what "box1" when you come back to the code at some point in the future. Better to introduce a class like "bio-box", which makes reference to a specific kind of element on the page (in this case, a box for short biographies).

One important thing to avoid is naming classes or ids after how the element looks on the page. For example, suppose that for some reason the last .bio-box on the test page has information that we want a user to be alerted to, which we want to indicate by setting the background color of the box to red. We could add a class of "red" to the last box (as in Listing 15), making sure it is separated from the other class by a space, and then style it in the CSS like in Listing 16.
Listing 15: Adding the class .red to a .bio-box.
index.html

.
.
.
<div class="bio-box">
  <a href="http://example.com/">I'm a link</a>
</div>
<div class="bio-box">
  <a href="http://example.com/">I'm a link</a>
</div>
<div class="bio-box">
  <a href="http://example.com/">I'm a link</a>
</div>
<div class="bio-box red">
  <a href="http://example.com/">I'm a link</a>
</div>
.
.
.

Listing 16: Creating the .red class styling.
index.html

.
.
.
<style>
  a {
    color: red;
  }
  #exec-bio {
    background-color: lightgray;
  }
  .bio-box {
    border: 1px solid black;
  }
  .bio-box a {
    color: green;
  }
  .red {
    background: red;
  }
</style>
.
.
.

When you save your work and refresh the browser, you’ll see that the background of the box has changed (Figure 18).
images/figures/naming-red
Figure 18: Sure, this worked. But is it a good idea?

But let’s say that at some point in the future we decide that red isn’t our favorite color for alerts anymore, and now we want to use purple. So we open up our project file, and in the CSS change the background property to purple, as in Listing 17.
Listing 17: The problem when you name classes based on appearance.
index.html

.
.
.
    <style>
      a {
        color: red;
      }
      #exec-bio {
        background-color: lightgray;
      }
      .bio-box {
        border: 1px solid black;
      }
      .bio-box a {
        color: green;
      }
      .red {
        background: purple;
      }
    </style>
.
.
.

Now the class name and the effect it has on the page not only don’t match up, they are downright confusing (Figure 19).
images/figures/naming-purple
Figure 19: Why do this to yourself?!

This might seem like no big deal on our simple test page, but imagine if that class were used on elements all over a project. We’d have two choices: go through and change all the class names on all the elements, or just live with the class and its effect being confusing.

Instead, if we use a naming convention where the class names are based on what the intended purpose is of the element on the page, and therefore used a more descriptive name like "alert", then we can change the text color without needing to worry about contradictory or confusing names (Listing 18).
Listing 18: A more appropriately named class based on the intention.
index.html

.
.
.
    <style>
      a {
        color: red;
      }
      #exec-bio {
        background-color: lightgray;
      }
      .bio-box {
        border: 1px solid black;
      }
      .bio-box a {
        color: green;
      }
      .alert {
        background: purple;
      }
    </style>
.
.
.
    <div class="bio-box alert">
      <a href="http://example.com/">I'm a link</a>
    </div>
.
.
.

With the convention shown in Listing 18, if we later decide that alerts should be purple instead of red, there’s nothing confusing in the code. Some other examples: instead of calling something "small", choose a class name like "collapsed" if that is the functionality; or use "disabled" instead of "gray" for grayed out elements that a user isn’t allowed to interact with.

Of course, there are exceptions, and ultimately the naming system is totally up to you, but as a rule of thumb, it’s a good idea to stick with functional naming (Box 7).
Box 7. Style Note: Naming conventions

Strict prescriptive class naming systems have become popular recently, and with good reason: there were a lot of projects out there with naming conventions that were completely arbitrary—projects that had more in common with a Dr. Seuss story than a coherent development project. These sorts of strict naming systems are frequently used when there is no limit to the number of developers who might work on a project over its lifetime (think of web applications developed and managed at large corporations).

We aren’t going to get into any of these in this tutorial, but we thought it would be a good idea to at least mention that they exist. If you get more into front-end development, it might not be a bad idea to look into some of the conventions other developers are using:

    Block Element Modifier (BEM)
    Object Oriented CSS (OOCSS)
    Scalable and Modular Architecture for CSS (SMACSS) 

Whether you find these systems useful or not, the most important thing is to strive for some semblance of consistency.
2.2 When and why

So, when are you supposed to use ids and when are you supposed to use classes? As noted in Section 1.5, ids are intended to target only one element on the page, while classes can target multiple things. To enforce this design, HTML elements will accept multiple class names on a single object (separated by spaces), but allow for only one id per element (anything after the first is ignored). But that isn’t the whole story, because browsers treat ids and classes differently, and here is the first place where we’re going to run the risk of starting a holy war…

Our view is as follows:

    You should strive to use ids only when you absolutely have to (for example, if you are using JavaScript, and then use them only for JavaScript).

Yes, in Section 1.5 we added an id to the first div and targeted styles at it, but that was just for demonstration purposes, and in general it’s a practice that should be avoided. The reason is that when you use an id to apply styles, it is nearly impossible to change that styling with another declaration without making your code full of ugly hacks.

To see why, take a look at Listing 19 and add our new .alert class onto that first div (the one that also has the id #exec-bio), while also changing the alert color back to red.
Listing 19: Adding an alert class to an element with an id.
index.html

<style>
.
.
.
.alert {
  background: red;
}
</style>
.
.
.
<div id="exec-bio" class="bio-box alert">
  <a href="http://example.com/">I'm a link</a>
</div>
<div class="bio-box">
  <a href="http://example.com/">I'm a link</a>
</div>
<div class="bio-box">
  <a href="http://example.com/">I'm a link</a>
</div>
<div class="bio-box alert">
  <a href="http://example.com/">I'm a link</a>
</div>
.
.
.

Save and refresh, and you’ll notice that nothing changed; even though you’d expect the background to be red, it isn’t, and instead looks just like Figure 18.

The problem is that ids are considered by the browser to have a higher specificity, and that means that any styles declared in the more specific statement will take precedence over less specific styles. You can think of classes like a machine gun spraying out lots of little projectiles, and ids like a rocket launcher. The style that gets launched by an id just has more power.

One way make the .alert style apply would be to increase the specificity of our declaration by adding a new declaration that targets any element that has both the id #exec-bio and the class .alert, as shown in Listing 20.
Listing 20: Overcoming the strength of an id style by combining the id and a class.
index.html

.
.
.
<style>
  a {
    color: red;
  }
  #exec-bio {
    background-color: lightgray;
  }
  .bio-box {
    border: 1px solid black;
  }
  .bio-box a {
    color: green;
  }
  .alert {
    background: red;
  }
  #exec-bio.alert {
    background: red;
  }
</style>
.
.
.

The CSS in Listing 20 chains together the rules for an id and a class using #exec-bio.alert, and its effect in this case is to add a red background to the div from Listing 19 (Figure 20).
images/figures/id-and-class
Figure 20: Combining the id and class makes for an unusually specific style.

Using a combined style selector like that will change the background color, but it will apply the style only in the specific situation where both that id and class are present. If your site relies on styles targeted at ids, then over time you’ll find yourself adding more and more of these hyper-specific declarations. That isn’t the most effective way to use CSS.

It’s better in the long run to use a system that’s modular, so that designing and developing the front-end of a site is like snapping together Legos. This way, you can add a class to an element and be confident that the styles from that class will be applied correctly.

In case you were wondering, the browser merges together all the different declarations and then sorts out conflicts property by property. So stronger declarations don’t override all styles on an object, only the properties that are included in that stronger declaration. So in the case of the .bio-box that we’ve been messing around with, all the properties in Listing 21 are being simultaneously applied.
Listing 21: All the styles that are affecting the one .bio-box.

#exec-bio {
  background-color: lightgray;
}
.bio-box {
  border: 1px solid black;
}
.alert {
  background: red;
}
#exec-bio.alert {
  background: red;
}

Through the magic of the browser, all those rules are merged, and conflicts are automatically resolved. In the case of Listing 21, the merged styling would look something like Listing 22 (which indicates unused rules with CSS comments, which are discussed further in Section 2.4).
Listing 22: The merged styles with the superseded ones commented out.

{
  /* background: red; */
  /* background-color: lightgray; */
  background: red;
  border: 1px solid black;
}

Because of the specificity of the .alert class, the background-color: red rule overrides both the general background: red and the more specific background-color: lightgray rules.21

Let’s take a closer look at how the browser determines which rules take precedence.
2.3 Priority and specificity

CSS was designed to allow for multiple stylesheets from multiple locations to influence the appearance of a single document without catastrophically crashing. The result is a system of priority and specificity rules devised to resolve contradictory style declarations like the ones we were playing with in Section 2.2.

To make this even clearer, let’s take a look at the simplified example shown in Listing 23, which uses a width set to a particular percentage. (We’ll learn more about percentages in Section 3.4.)
Listing 23: Different rules targeting the same class.
index.html

.
.
.
<style>
  .
  .
  .
  .bio-box {
    width: 100%;
  }
  .bio-box {
    width: 50%;
  }
</style>
.
.
.

If you update the style section of your test page with the styling above, you’ll notice that the boxes end up being half of the width (50%) of the page—i.e., the second rule in Listing 23 is the one that gets applied (Figure 21). This is part of a general pattern: in the case of conflicting CSS rules, the final one gets applied.
images/figures/50_percent
Figure 21: A 50%-width box showing how the final CSS rule gets applied.

The full list of CSS priority rules appears in Table 1. You don’t need to memorize this table—over time you’ll get a feel for how the priority works. Also, of all these rules, only numbers 3 and 5–8 are priorities that you’ll have to understand, and you should strenuously try and avoid using numbers 1 (Box 8) and 2 (makes for difficult-to-maintain code). Numbers 4 and 9 are out of your control.
1 	Importance 	Adding !important (e.g., “width: 100% !important”) to a value overrides all other similar styles (but never use !important (Box 8)
2 	Inline 	A declaration that is put on an element using style=
3 	Media Type 	When a style is applied through a media query (more in Chapter 9)
4 	User defined 	Most browsers have the accessibility feature: a user defined CSS
5 	Selector specificity 	Styling applied via a class or id overwrites generic styling
6 	Rule order 	The last style written has priority
7 	Parent inheritance 	If there is no style specified, then children inherit styles from their parent
8 	CSS 	CSS rules from a stylesheet or style block that are applied to generic elements.
9 	Browser defaults 	Lowest priority, these are the default styles that browsers ship with
Table 1: CSS priority rules.

Now you might be asking, “OK, but now what happens when applying two styles that have the same priority?” In this case, we need to consider specificity as well as priority, which is used to resolve any situation where multiple styles with the same priority level are applied (#5 in Table 1).

At the most basic, specificity just means that the more specific you are when you target an element, the greater the strength the browser will give to the styles in that declaration. For example, suppose we wanted to make all a elements gray by declaring a style as in Listing 24.
Listing 24: A not-very-specific style.

a {
  color: gray;
}

Without even needing classes or ids, we could override this style by being a little more specific. So if we had links that were inside of h1 headers, we could make all as that are inside of those h1 elements green using a declaration like in Listing 25
Listing 25: A more specific style.

h1 a {
  color: green;
}

That slightly more specific declaration override the initial styling that made the a text gray, and instead the text would be green. (This is the technique we used in Listing 11).

Table 2 has a more detailed listing of the values that different selectors are assigned by the browser. The styles get more specific as you go down the table, meaning that lower ones would override the styles above.

You’ll notice that there isn’t a simple numbering system for Table 2 like there is for the priority list in Table 1. That’s because the specificity uses a separate system that has different levels noted by adding new numbers with a comma—its confusing and we’ve never actually heard of a developer work through a specificity problem using the number system, but we’ve included it for the sake of completeness.
Simple HTML selector 	em {color: #fff;} 	1
HTML selector targeting element inside another element 	h1 em {color: #00ff00;} 	2
CSS class name 	.alert {color: #ff0000;} 	1,0
HTML element with a class name 	p.safe {color: #0000ff;} 	1,1
CSS id 	#thing {color: #823706;} 	1,0,0
CSS id with a class name 	#thing .property {color: #823706;} 	1,1,0
Inline style 	style="color: transparent;" 	1,0,0,0
Table 2: The confusingly complex rules of specificity.

This all seems really complicated, right?

Well, most developers don’t actually know all these rules by heart. Instead, what we all use are systems of simple conventions like trying to keep declarations simple and general, with exceptions targeted via a class, not using ids to target styles, not using !important (Box 8),22 etc. Over time you’ll build up a gut feeling for the specificity.
Box 8. Style Note: Never use !important

There’s another bad way of getting a style to apply, and that is to use the !important flag to the declaration, which automatically overrides any conflicting styles (Table 1). You should think about !important (read “not important”) like this: if you’ve had to use !important, then you’ve failed at styling something.

The problem with using !important is that once you start using it, there’s a tendency to use it more and more over time, since the only way to overcome a style that was applied with !important is to use another !important. Such proliferating !important rules are the tribbles of CSS.
images/figures/tribbles

It is always better to rethink how you are styling something than to use !important.

Now that you know about !important, erase it from your memory.
images/figures/forget

One way to avoid getting caught in situations where overlapping layers of complexity keep your styles from being applied is to try to keep your selectors as simple as possible (Listing 26), rather than using an ugly and complicated set of selectors (Listing 27).
Listing 26: Good clean CSS.

.bio-box a {
  color: green;
}
.alert {
  background: red;
}

Listing 27: Ugly and complicated CSS.

body div#exec-bio.bio-box a {
  color: orange;
}

Often simplicity is the best solution.
Exercises

    Use the !important flag to force the background color of the .alert class to be red (make sure to remove #exec-bio from the style).
    Remove what you did in Exercise #1 and promise to never use !important again (Box 8).
    Try changing the color of the .bio-box a links not by changing the color property on the existing style, but instead by adding a new identical selector below the existing one and a new color declaration that changes the link color to pink. 

2.4 How to be a good styling citizen

So, how should you be a good developer and use CSS selectors in a reasonable way that takes advantage of the crazy priority and specificity rules… without requiring a lot of mental overhead? Start with the concept we mentioned in Section 2.2: that classes should be combined like Legos to get the result we are looking for. Make design choices that are modular so that your styles only affect things inside of modules instead of leaking out to affect elements site-wide.

If you need to have a module do slightly different things depending on placement or status, multiple classes on an element are a valid usage of the class selector, but at the same time don’t take that to mean that you need to give every single element on the page a class, or (even worse) multiple classes. It’s a fine balancing act between under- and over-classing your markup.

Looking at the styling we’ve done, you might have wondered why we didn’t give the links in the .bio-boxes classes of their own. We definitely could have, and there would have been nothing wrong with that, but this is another one of those subjective areas in styling. One good practice is to divide up the styling into two different categories: global styles that will apply in many different places in order to create greater consistency, and individual sections that are self-contained modules of functionality or content.

As an example, let’s assume that the .bio-boxes are going to be located in a part of the site that always has one link in each box—they are going to be repeating and regular modules. In this case, we can just skip classing the individual links and apply a more general style for an a tag within the .bio-box, without needing to drill down and add new styles. But if we need to add another link, then we’d have to consider whether or not we want the two links to look the same. If not, it would be necessary to come up with a different way to target the elements.

Let’s add some content to make these ideas more concrete. Replace the dummy .bio-boxes with the markup shown in Listing 28, which includes the entire page to help you sync up. Note that, among other things, we’ve eliminated the exec-bio id, which (as mentioned in Section 2.2) we recommend using only when absolutely necessary, and we’ve also slimmed down the CSS rules.
Listing 28: Using more realistic example HTML.
index.html

<!DOCTYPE html>
<html>
  <head>
    <title>Test Page: Don't Panic</title>
    <meta charset="utf-8">
    <style>
      a {
        color: red;
      }
      .bio-box {
        border: 1px solid black;
      }
      .bio-box a {
        color: green;
      }
    </style>
  </head>
  <body>
    <h1>I'm an h1</h1>
    <ul>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
    </ul>
    <h2>I'm an h2</h2>
    <div class="bio-box">
      <h3>Michael Hartl</h3>
      <a href="http://twitter.com/mhartl">here</a>
      <p>
        Known for his dazzling charm, rapier wit, and unrivaled humility,
        Michael is the creator of the
        <a href="http://railstutorial.org/">Ruby on Rails
        Tutorial</a> and principal author of the
        <a href="https://learnenough.com/">
        Learn Enough to Be Dangerous</a> introductory sequence. Michael
        is also notorious as the founder of
        <a href="http://tauday.com/">Tau Day</a> and author of
        <a href="http://tauday.com/tau-manifesto"><em>The Tau
        Manifesto</em></a>, but rumors that he's secretly a supervillain
        are slightly exaggerated.
      </p>
    </div>
    <div class="bio-box">
      <h3>Lee Donahoe</h3>
      <a href="https://twitter.com/leedonahoe">here</a>
      <p>
        When he's not literally swimming with sharks or hunting powder stashes on
        his snowboard, you can find Lee in front of his computer designing
        interfaces, doing front-end development, or writing some of the
        interface-related Learn Enough tutorials.
      </p>
    </div>
    <div class="bio-box">
      <h3>Nick Merwin</h3>
      <a href="https://twitter.com/nickmerwin">here</a>
      <p>
        You may have seen him shredding guitar live with Capital Cities on Jimmy
        Kimmel, Conan, or The Ellen Show, but rest assured Nick is a true nerd at
        heart. He's just as happy shredding well-spec'd lines of code from a tour
        bus as he is from his kitchen table.
      </p>
    </div>
    <div class="bio-box">
      <h3>??</h3>
      <p>
        The Future
      </p>
    </div>
  </body>
</html>

If you save and refresh the page, you’ll find that all of the links in the boxes look the same, i.e., they’re green (Figure 22).
images/figures/green_links
Figure 22: All-green links.

Looking back at Listing 28, we see that each bio contains a link to the corresponding person’s Twitter account, and it would be nice to distinguish these visually from the others. We’ll continue to improve these links throughout the tutorial, but for now we’ll just make them blue, while keeping the others green.

One way to do this would be to retarget the style that makes the links green by making the style only apply to links that are inside of paragraph p tags, as shown in Listing 29.
Listing 29: Styling link color inside of the paragraphs.
index.html

.bio-box p a {
  color: green;
}

This would restore the Twitter links to the default blue, reserving green for links inside paragraph tags, but it would also start bumping up against a suggested three selector limit rule of thumb, as discussed in Box 9.
Box 9. Style Note: Selector depth

In general, and for a couple of reasons, it’s a good idea to keep the number of selectors in a declaration under three (i.e., to three or fewer). This might seem easy right now with our super-simple test page, but on a complicated site things can get very messy. One obvious reason you want your selectors to be as short as possible is for readability. It’s just easier to find what you are looking for in a big section of CSS if the selectors are short.

The other reason is that CSS selectors are read by the browser from right to left, so the more selectors there are, and the more general they are, the more work the browser has to do to render your page. It’s a little counter-intuitive, since you’d think that the browser would start on the left and narrow down the scope of the styling by moving right… but for technical reasons it doesn’t. So if you declared a style using #first-table tr td h1, the browser would first identify all h1s, then all tds, then all trs, and finally restrict everything to just the elements that are in something with an id of #first-table.

If you have lots of elements on a page, this kind of inefficiency can really slow down rendering times, so keeping the number of selectors down is good both for us (the developers) and for our users.

Using the rule shown in Listing 29 would be fine—we’d just have to pay attention and avoid making it more complicated in future changes—but let’s instead use a more robust practice by applying the specificity rules to get what we want while still adhering to Box 9’s three-selector limit. We can accomplish this by changing the style selector back to just .bio-box a while adding a class of .social-link to all the Twitter links (Listing 30).
Listing 30: Adding a class to the social media links.
index.html

.
.
.
<a href="http://twitter.com/mhartl" class="social-link">here</a>
.
.
.
<a href="http://twitter.com/leedonahoe" class="social-link">here</a>
.
.
.
<a href="http://twitter.com/nickmerwin" class="social-link">here</a>
.
.
.

Then we can style the links by adding the new class declaration in the CSS, as in Listing 31. (Put this new declaration somewhere below the .bio-box a declaration.)
Listing 31: Adding a style declaration for our social links.
index.html

.
.
.
a {
  color: red;
}
.bio-box {
  border: 1px solid black;
}
.bio-box a {
  color: green;
}
a.social-link {
  color: blue;
}
.
.
.

Now, any links that are inside of paragraphs will be green, while the social links will be a nice blue (Figure 23).
images/figures/social-blue
Figure 23: The class combined with a allows the styling to apply.

When combined, the class and element selectors have higher specificity than .bio-box a. So, if you were to remove the a from .social-link in the selector, the link would turn green again.

So what’s the point of this seemingly simple exercise?

It wouldn’t seem like choosing a link color is all that important, but little mistakes in how you deal with specificity at the beginning of a project can cause problems down the road. Even in this simplified example, there are a bunch of decisions that have to be made that could affect the future development of the page. Choosing poorly could require us to have to go back to the code and rewrite it if our original styling was too generic or restrictive.

For example, suppose we kept the green link styling targeted using .bio-box p a. If we then later wanted to put images into the links—along with styles that target the images—we would have to add classes to all the images to cleanly target them (because .bio-box p a img is too many selectors deep). On the other hand, while classes for the images might be a good option if there are only a few, if there are a whole lot of images it could be a hassle to add in class names on each and every one.

You could get around both of these problems by adding a class to the p tag, which would let you cut out a level in the declaration, but then what happens if you want multiple paragraphs in a bio? Now each p would need a class… and you are back into the mess of having to add class names to a large number of elements. An easy solution would be to wrap that whole text section in a new div with a class like .bio-copy, and then target the links inside with .bio-copy a and images in links with .bio-copy img.

Let’s look at an example of what it looks like to wrap the text content in an element with its own class to allow for more precise targeting. This involves adding .bio-copy wrappers around each biography’s copy,23 as shown in Listing 32, which we’ll put to use in a moment.
Listing 32: Wrapping each of the bios in a div to better-target text.
index.html

.
.
.
<div class="bio-box">
  <h3>Michael Hartl</h3>
  <a href="http://twitter.com/mhartl" class="social-link">here</a>
  <div class="bio-copy">
    .
    .
    .
  </div>
</div>

<div class="bio-box">
  <h3>Lee Donahoe</h3>
  <a href="https://twitter.com/leedonahoe" class="social-link">here</a>
  <div class="bio-copy">
    .
    .
    .
  </div>
</div>

<div class="bio-box">
  <h3>Nick Merwin</h3>
  <a href="https://twitter.com/nickmerwin" class="social-link">here</a>
  <div class="bio-copy">
    .
    .
    .
  </div>
</div>
.
.
.

Now let’s look at another styling wrinkle. If you were to stick with the style declaration a.social-link from Listing 31 as the way to target all .social-links, then you’d have to ask yourself, “Could there be a situation where I want the styling of a .social-link on an element that isn’t actually a link?” It sounds a little weird to ask the question, since it would seem that if you call something a link, you’d expect it always to be a link, but you’ll often have styling for links that you need to apply to something that isn’t an a.

An example of this would be if you have a navigational menu where you have a bunch of links to pages. Often, you want to have a menu item for the current page a user is looking at, and you don’t want users to be able to click a link for the page they are already on (that would refresh the page), but you do want this type of menu item to look like the rest of the navigational links. In that case, the menu item that isn’t a link would need to inherit all the same styling that the links got, and in our example that would be difficult if the selector was a combined HTML element and class name: a.social-link.

To allow the .social-link class to change the styling of the link without combining the HTML element and the class name, we should retarget the generic declarations in favor of the more specific method using the .bio-copy class name from Listing 32. The result is a change from the current .bio-box rule from Listing 26 to the more targeted style, which affects only links that are in the .bio-copy section of the boxes:

.bio-copy a {
  color: green;
}

At this point, we can also change a.social-link to just .social-link:

.social-link {
  color: blue;
}

Putting these together gives the final index page for this chapter, shown in Listing 33. Note that we’ve eliminated the style for the exec-bio id, which is no longer needed now that the corresponding id has been eliminated (Listing 28).
Listing 33: Applying good class and style practices.
index.html

<!DOCTYPE html>
<html>
  <head>
    <title>Test Page: Don't Panic</title>
    <meta charset="utf-8">
    <style>
      a {
        color: red;
      }
      .bio-box {
        border: 1px solid black;
      }
      .bio-copy a {
        color: green;
      }
      .social-link {
        color: blue;
      }
    </style>
  </head>
  <body>
    .
    .
    .
  </body>
</html>

Because the CSS changes we’ve just made were a refactoring, the appearance should be the same as before (Figure 23).

As a final step, we’ll add some descriptive CSS comments while rearranging our CSS rules so that they are grouped thematically, according to whether they’re global, apply only to social links, or apply to the page biographies. This practice makes it easier to navigate, read, and edit the CSS rules later on (Box 10). The result appears in Listing 34, which shows the full page in case you need to sync up.
Listing 34: The final form of our page for this chapter.
index.html

<!DOCTYPE html>
<html>
  <head>
    <title>Test Page: Don't Panic</title>
    <meta charset="utf-8">
    <style>
      /* GLOBAL STYLES */
      a {
        color: red;
      }

      /* SOCIAL STYLES */
      .social-link {
        color: blue;
      }

      /* BIO STYLES */
      .bio-box {
        border: 1px solid black;
      }
      .bio-copy a {
        color: green;
      }
    </style>
  </head>
  <body>
    <h1>I'm an h1</h1>
    <ul>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
      <li>
        <a href="http://example.com/">Link</a>
      </li>
    </ul>
    <h2>I'm an h2</h2>
    <div class="bio-box">
      <h3>Michael Hartl</h3>
      <a href="http://twitter.com/mhartl" class="social-link">here</a>
      <div class="bio-copy">
        <p>
          Known for his dazzling charm, rapier wit, and unrivaled humility,
          Michael is the creator of the
          <a href="http://railstutorial.org/">Ruby on Rails
          Tutorial</a> and principal author of the
          <a href="https://learnenough.com/">
          Learn Enough to Be Dangerous</a> introductory sequence. Michael
          is also notorious as the founder of
          <a href="http://tauday.com/">Tau Day</a> and author of
          <a href="http://tauday.com/tau-manifesto"><em>The Tau
          Manifesto</em></a>, but rumors that he's secretly a supervillain
          are slightly exaggerated.
        </p>
      </div>
    </div>
    <div class="bio-box">
      <h3>Lee Donahoe</h3>
      <a href="https://twitter.com/leedonahoe" class="social-link">here</a>
      <div class="bio-copy">
        <p>
          When he's not literally swimming with sharks or hunting powder
          stashes on his snowboard, you can find Lee in front of his computer
          designing interfaces, doing front-end development, or writing some of
          the interface-related Learn Enough tutorials.
        </p>
      </div>
    </div>
    <div class="bio-box">
      <h3>Nick Merwin</h3>
      <a href="https://twitter.com/nickmerwin" class="social-link">here</a>
      <div class="bio-copy">
        <p>
          You may have seen him shredding guitar live with Capital Cities on
          Jimmy Kimmel, Conan, or The Ellen Show, but rest assured Nick is a
          true nerd at heart. He's just as happy shredding well-spec'd lines
          of code from a tour bus as he is from his kitchen table.
        </p>
      </div>
    </div>
    <div class="bio-box">
      <h3>??</h3>
      <p>
        The Future
      </p>
    </div>
  </body>
</html>

Box 10. Style Note: Group your style and add comments!

It might seem obvious, but if you have any concern for other human beings who might ever look at your code, for the love of $DEITY, please group all styles that relate to the same part of the site in the same place, and to be extra helpful add in a comment or two that explains what the styles are for!

CSS comments are any text that is between the asterisks /* */, which looks like this in practice:

  /* HOMEPAGE STYLES */

Comments don’t affect how the code is displayed to users, but you should know that they can be seen by anyone who browses the site source code… so don’t put anything into the comments you’d be embarrassed to say out loud in a crowded place.

From this point on, when we add new styles we’ll usually include a comment name for the section, like the /* HOMEPAGE STYLES */ above. If the styles should be grouped into an existing section, we’ll indicate that using this convention:

  /* HOMEPAGE STYLES */
  .
  .
  .
  .some-style {
  }

That means that you should put the new styles somewhere after the existing styles in that section (represented by the vertical ellipsis). The only time that we won’t include the section name when adding styles is when we are already working and making changes in that section.
Exercises

    Add a new style that sets generic divs to have a border style of border: 1px solid green;. Save and refresh and all divs other than the .bio-boxes should have a green border. Change the selector to div.bio-box, and then save and refresh.
    Add the .social-link class onto the h1. Even though it isn’t a link, the color should change.
    Add your own comment to the style section, and inside add html{background:red;}. Save and refresh. Then delete the first /* and then save and refresh. Your page should look very different—always remember to balance your comment tags. 

3 CSS values: color and sizing

Now that we’ve learned how to make our site’s skeleton, it’s time to start fleshing it out with some more CSS values. In this chapter, we’ll learn about two of the most important kinds of values that CSS can apply to HTML elements: color and sizing. These will allow us to go from putting elements on a page (Chapter 2) to controlling the color of the elements and how big they are.

Values in a CSS declaration (Figure 16) can take a lot of different forms, from numbers, to dimensions, to idiosyncratic options, to colors, etc. On top of all of that, there are shorthand methods that let you write style multiple properties and values on a single line. Most CSS declarations and values are self-explanatory—not too many people are going to be confused by text-align: left—but there are quite a few that are have extra complications, weird exceptions, or just odd ways of defining a value.

The next few sections are going to recap some style values that you might have seen before, but we’ll also dive into some of the less obvious use cases.
3.1 CSS color

So far in this tutorial we’ve defined colors with descriptive words like red, green, and lightgray. CSS supports a large number of such color names, and there are online references that list all the color names supported by all browsers. It’s not the most flexible or even the most common system of defining CSS colors, though, and in this section we’ll discuss other more powerful ways of applying colors in CSS.
Hexadecimal colors

As discussed previously in Learn Enough HTML to Be Dangerous, one common method for defining colors is hexadecimal RGB (red-green-blue). While this name might sound complicated, in practice the concept is fairly simple.

A quick way to show how hexadecimal color works is to change the color of the red link text on our sample page to its equivalent hexadecimal RGB color. Change the word red in the color property to the one shown in Listing 35.
Listing 35: Switching from color name to a specific color value.
index.html

/* GLOBAL STYLES */
a {
  color: #ff0000;
}

Now when you save and refresh your browser, the link text will still be the same bright red (Figure 24).
images/figures/color-nochange
Figure 24: Sometimes no change is good change.

The reason the color system is called hexadecimal RGB is that it uses base-sixteen numbers instead of the usual base ten (“hexadecimal” is a mishmash of Greek and Latin meaning “six” (hex) and “tenth” (decimal)). In hexadecimal, or hex for short, 0 is equal to 0, and f is equal to 15—letting you count 16 values in a single numeral (Table 3).
0 	1 	2 	3 	4 	5 	6 	7 	8 	9 	10 	11 	12 	13 	14 	15
0 	1 	2 	3 	4 	5 	6 	7 	8 	9 	a 	b 	c 	d 	e 	f
Table 3: Counting in hex.

In base ten, we can count from 0
to 99 with two digits, where 99=102−1. Similarly, hex lets us count from 0 to ff=162−1=255

. In other words, putting two hex numbers next to each other lets us count from 0 to 255 using just two characters, with 00 = 0 and FF or ff = 255 (CSS hex is case-insensitive, so it doesn’t matter if you use upper- or lower-case letters).

A computer monitor consists of picture elements, or pixels, and displays colors by combining the light from red, green, and blue elements of a pixel (Figure 25). Hexadecimal RGB puts three sets of two hex numbers next to each other to define the red, green, and blue values that make up a single color, so #ff0000 can also be read as red=ff, green=00, blue=00 or red=255, green=0, blue=0. As we mentioned in Listing 35, this is the same as the color word red.
images/figures/screen_pixel
Figure 25: The elements in a single pixel of a computer screen’s display.

If all three colors are turned on (each set to ff, or #ffffff), the pixel will look white; if they are all off (each set to 00, or #000000), it will look black. Combinations of the three colors can be used to create all the colors you see (Figure 26).
images/figures/hex
Figure 26: Some hexadecimal color examples.

CSS also supports a useful shorthand in the common case that some of the hex numerals are the same. If the digits are the same, as in #222222, #cccccc, or #aa22ff, we can shorten the whole number to just three digits, like this: #222, #ccc, or #a2f. When the browser sees only three digits, it fills in the missing ones.

Thus, using #f00 in place of #ff0000 (Listing 35) should lead to the same color red (Section 3.1.3). The result of making this change on our sample site is shown in Listing 36. The result should be the same as the previous version shown in Figure 24.
Listing 36: Using the more compact hex notation.
index.html

.
.
.
/* GLOBAL STYLES */
a {
  color: #f00;
}
.
.
.

The RGB color system might seem confusing at first, but with practice you’ll quickly come to understand how the three values work together to make different colors, and different shades of those colors. For making more complicated colors, we suggest using a color picker, but there are some common cases that you should know off the top of your head.

For instance, the grayscale spectrum from black to white always has all three hex numbers the same: all 00 (or #000000) is black, all ff (or #ffffff) is white, and numbers in the middle, like #979797, are some shade of gray (Figure 27).24
images/figures/hex-grey
Figure 27: Hexadecimal grayscale.

In practice, most web developers and designers use common hex values interchangeably with their color-word equivalents, so it’s important to know that #000 and #000000 are both black, #fff and #ffffff are both white, #00f and #0000ff are both blue, etc.
Setting color and transparency via rgb() and rgba()

In addition to using RGB hex, you can also use RGB directly using rgb(), which allows you to use decimal numbers in place of hex. In other words, rgb(255, 255, 255) is the same as #ffffff, etc. But the main reason to use RGB directly is to set transparency via the rgba() command.

In rgba(), the a stands for alpha, because the conventional name for transparency level in image processing is the alpha level. The alpha level is indicated using a number between 0 and 1, where 0 is transparent, 1 is opaque, and decimals in between define all the levels of partial transparency (50% is 0.5, 25% is 0.25, etc.).

For example, let’s make the social link’s background a transparent gray using rgba(). We’ll select a fairly dark gray, corresponding to RGB values of 150 each (out of 255), and initially set an opacity of 1 (Listing 37).
Listing 37: Using the rgba() property to set an opaque background color.
index.html

.
.
.
.social-link {
  background: rgba(150, 150, 150, 1);
  color: blue;
}
.
.
.

The result appears in Figure 28.
images/figures/social-rgba-opaque
Figure 28: Social links with an opaque gray background.

Now let’s switch to 50% opacity (which is the same as 50% transparency), as shown in Listing 38.
Listing 38: Using the rgba() property to set a partially transparent background color.
index.html

.
.
.
.social-link {
  background: rgba(150, 150, 150, 0.5);
  color: blue;
}
.
.
.

As you can see by comparing Figure 28 with Figure 29, the social links now have a partially transparent gray background. (We’ll see another more practical example of transparency in Section 5.7.1.)
images/figures/social-rgba-bg
Figure 29: Blue text and 50% transparent gray background.

Amazingly, there are still more ways to set colors in CSS (HSL and HSLa), but we aren’t going to go into them, as you are far less likely to encounter them in practice.
Exercises

    Use a color picker, change the color of the links on the page (the a declaration) to a light purple color using a hex value.
    Convert remaining color words to their hex equivalents, using the more compact notation if possible.
    Use the rgba color system to fade the links by making their opacity 20%.
    Set the links that are inside of the lis at the top of the page to have a class of .social-link. 

3.2 Introduction to sizing

In both Learn Enough HTML to Be Dangerous and in this tutorial, we frequently use pixel measurements to set the sizes of things like fonts, margins, and padding (Chapter 4), but there are actually a confusingly wide variety of different ways to define the size of elements. As a result of having to reliably display multiple generations of HTML across many different computers and devices, web browsers are an unimaginably complicated kluge of different standards. No one sat down and planned out how the web would work in one go—features and support aggregated over time like a snowball rolling downhill, as various people suggested new methods of styling. Dimensional units are one area that has seen many such additions over time.

You might think it would be easiest for us to do what we’ve been doing and almost always specify sizes using pixels (px)—after all, isn’t a screen just a big grid of pixels?

Sizing an element this way would work great if everyone in the world had exactly the same screen size and resolution, but they don’t, and some screens combine many physical pixels into a smaller number of virtual pixels. That means that when you size something to look good on your screen, someone using a lower resolution screen might find the element size to be unusably large, or if they are using a high-resolution screen (like a Retina display on an iPhone or iMac) it would look really small (Figure 30).
images/figures/density
Figure 30: Different-sized displays have wildly different pixel densities.

The good news is that modern browsers can zoom in and out to make things easier, but that can cause page layouts that use absolute sizes to break. Also, modern devices can scale their output to make something that has an incredibly high pixel density work as though it were a normal lower density screen

For most of the last few years, the agreed-upon modern best practice has been to mostly use relative sizes, which style element sizes based on the size of other elements, or even to the size of the screen. For example, for a header you might say (in CSSese), “I want my header text to be four times as big as the default text size”, and the browser would figure out the rest.

This type of relative sizing helps deal with the different screen scale issues, and also allows for easy resizing of the contents of a page. If you really want to, though, you can use absolute sizes pretty much anywhere, as a lot of issues with browsers have been worked out, but it’s still a lot easier to stick with the convention and use relative sizes in most cases.

The rest of this chapter takes closer look at some of the most common units, their uses, and some of their caveats.
3.3 Pixels (and their less-used cousin, the point)

The pixel (px) and point (pt) units in CSS are absolute measurements that are defined as 1/96 of an inch for a pixel, and 1/72 of an inch for a point. From this point on we’re going to ignore the point because no one really uses it for web sizing (it’s a holdover from the world of print design), and because it work justs like pixel (just with a different base size). Pixels, on the other hand, are most definitely useful (Box 11).
Box 11. Style Note: Anti-pixel Fundamentalists

As you keep progressing in your understanding of web development, you will inevitably come across people who are on an anti-pixel crusade. They believe that you should never use absolute sizes and do everything relatively. The truth is that there is a time and a place for everything, even absolute units like the pixel.

Some measurements just feel better or make more sense in pixels (hooray for subjectivity!), such as margins and padding (Chapter 4). Sure, you could define those using some of the relative measures we’ll learn about below, and define all padding and margins based on the size of the size around it, but sometimes it is nice to know that whatever zoom level a user goes to there will be exactly 40 pixels of padding or margin around an element.

The real determining factor is how what you are designing is going to be used. If that pixel unit makes your job easier, and it is used in a place where it will never cause the layout to break, then go ahead and use it. Just know that if you get complaints from users that the site is breaking you’ll probably have to redo the sizing to be relative!

Using an absolutely defined unit is great if you want to define the size of an element in a way that isn’t dependent on the size of the browser or screen resolution, or anything else on the page, but it can lead to situations where the size of elements is completely inappropriate for a user’s device. This type of unit isn’t an inherently good or bad thing; you just need to be aware that anything sized using an absolute measurement is not going to be resized relative to anything else on the page—many sites have a mix of absolutely sized and relatively sized elements. The trick comes in knowing when to use the different units.

For instance, if you have banner ad images on your site, you are selling that advertising space based on the size of the element (one of the most common ads is the 728x90 leaderboard ad, as in Figure 31). In that situation, you want the ads to be defined with absolute dimensions and not be relative (after all when you think about it, you are selling screen real estate, you want to make sure the size of the ad is what they paid for).
images/figures/ad
Figure 31: You’ve seen this sort of ad in a million places.

Images are also always sized by the browser, so that 1 pixel of the image equals one pixel on the browser. It’s possible to have the browser resize images and use relative sizes, but the underlying default size of the image is 1 pixel to 1 pixel. This also is why you should never scale an image up from its default size in a browser—resizing should only be done to make an image smaller than it really is; otherwise, the browser has to spread pixels from the image over multiple pixels on the screen, and the image will look terrible (Figure 32).
images/figures/image_bad
Figure 32: Bad image resizing is bad.

So, that all still sounds reasonable right? Why can’t we just use px measurements for everything if 96 pixels equals an inch? Well, not so fast. It turns out that a “screen inch” made up of 96 pixels isn’t actually always the same as a real-world inch—for that measurement to be accurate, every screen’s pixel density would have to be 96 pixels per inch.

Unfortunately, this is not the case. Modern smartphones and high-end displays have pixel densities of 400 pixels per inch and up, and the operating systems that run on them are often scalable, meaning that what you see on the screen can be resized in a way that isn’t dependent on the physical number of pixels in the display—a bunch of smaller physical pixels are packaged together into a bigger “virtual” pixel. The point is, pixels at the software level no longer are directly related to physical pixels. As a result, the exact length of a 96px line is difficult to guarantee in a way that is universal for all users and screens.

One place where you will often see pixel sizes used online is in the definition of font sizes, which determine the size of text on the page. (This is also a place where you will find the most heated “pixel vs. non-pixel” holy wars.) Part of the reason for the prevalence of absolute sizing in fonts is that it’s a holdover from the days when pixel sizing was the only way to define font sizes on computers, and part of it is because there were people who were used to the conventions of print design where there were design requirements that said “this font should be exactly 24 points”. When transitioning from print to screen, people familiar with absolute print sizing just brought their habits over to the web. So if a design in Photoshop had font that was 24pt, they’d make they design on the site 24px.

Absolute sizes were fine for the period when pretty much all screens had the same characteristics (and there were no other options), but over time screen sizes, resolution, and densities proliferated, and the inflexibility of absolute font sizes made relative sizing the preferred method.

There is another caveat that should make you not want to use pixels for fonts: If you set font sizes using pixels and then want to change some sizes later (either for a mobile-specific view or just because you didn’t like the way it looked), you will have to go through and change every place where you defined a font size. If you had used relative values for those fonts, you could make changes in only one place, and everything else would inherit the new styling while still displaying in proportion. Making all text on a page bigger, or smaller, could be as easy as changing a single value.

So, with all those warnings about how you shouldn’t use pixel sizes for fonts… let’s use pixel sizes for fonts, and for element sizing, in a little quick pixel exercise! We’ll make the .bio-boxes have a width of 200px, and set the font size of the h2 element to be 30px, as shown in Listing 39. (We’ll undo this font-sizing in Section 3.6).
Listing 39: Styling elements with pixel values.
index.html

/* GLOBAL STYLES */
.
.
.
h2 {
  font-size: 30px;
}

/* BIO STYLES */
.
.
.
.bio-box {
  border: 1px solid black;
  width: 200px;
}
.
.
.

After saving and refreshing, your page should look like Figure 33.
images/figures/size-px
Figure 33: Hey look, resized elements. Woo.
Exercises

    You can (and should) use pixels to set the width of borders. Try changing the width of the .bio-box borders to 10px. 

3.4 Percentages

We’ve already sized elements using percentages earlier in the tutorial (Section 2.3), and from that you might be able to guess how useful this measurement can be when you are trying to use relative sizes to force an element to fill a space. There are a few catches, though:

    Percentage sizing is based on the parent container that an element is wrapped by—it isn’t determined by the size of the browser, or the page as a whole.
    Percentage heights are a little weird because they require a set height on the parent element—they can’t just assume a height the way that they assume a width.
    Percentages for fonts can be multiplicative, and aren’t based on the size of the parent element at all. 

Let’s take a look at how percentages work, and you’ll see what we are talking about. Add a new div that wraps the four .bio-boxes, and set the class of that div to bio-wrapper (Listing 40).
Listing 40: Adding a wrapper around the bio-boxes and giving it a class.
index.html

.
.
.
<div class="bio-wrapper">
  <div class="bio-box">
    <h3>Michael Hartl</h3>
    <a href="http://twitter.com/mhartl" class="social-link">
      here
    </a>
    <div class="bio-copy">
      <p>
        Known for his dazzling charm, rapier wit, and unrivaled humility,
        Michael is the creator of the
        <a href="http://railstutorial.org/">Ruby on Rails
        Tutorial</a> and principal author of the
        <a href="https://learnenough.com/">
        Learn Enough to Be Dangerous</a> introductory sequence. Michael
        is also notorious as the founder of
        <a href="http://tauday.com/">Tau Day</a> and author of
        <a href="http://tauday.com/tau-manifesto"><em>The Tau
        Manifesto</em></a>, but rumors that he's secretly a supervillain
        are slightly exaggerated.
      </p>
    </div>
  </div>
  <div class="bio-box">
    <h3>Lee Donahoe</h3>
    <a href="https://twitter.com/leedonahoe" class="social-link">
      here
    </a>
    <div class="bio-copy">
      <p>
        When he's not literally swimming with sharks or hunting powder stashes on
        his snowboard, you can find Lee in front of his computer designing
        interfaces, doing front-end development, or writing some of the interface
        -related Learn Enough tutorials.
      </p>
    </div>
  </div>
  <div class="bio-box">
    <h3>Nick Merwin</h3>
    <a href="https://twitter.com/nickmerwin" class="social-link">
      here
    </a>
    <div class="bio-copy">
      <p>
        You may have seen him shredding guitar live with Capital Cities on Jimmy
        Kimmel, Conan, or The Ellen Show, but rest assured Nick is a true nerd at
        heart. He's just as happy shredding well-spec'd lines of code from a tour
        bus as he is from his kitchen table.
      </p>
    </div>
  </div>
  <div class="bio-box">
    <h3>??</h3>
    <div class="bio-copy">
      <p>
        The Future
      </p>
    </div>
  </div>
</div>
.
.
.

This wrapper is going to be the parent container that determines the size of the children .bio-boxes for which we’ll set a percentage width. Add a style declaration that sets the width of this new class to be 500px, and also change the width of the .bio-boxes from the rather squished 200px in Listing 39 to 50%, as seen in Listing 41.
Listing 41: Changing the width of the parent element.
index.html

.
.
.
.bio-wrapper {
  width: 500px
}
.bio-box {
  border: 1px solid black;
  width: 50%;
}
.
.
.

Still pretty squished, right (Figure 34)?
images/figures/size_percent-small
Figure 34: Still not a lot of room for those boxes.

Those boxes are small because they are each taking their width setting as 250px (50% of the 500px wide parent). In order to get them to stretch across the page, we need to make their parent stretch all the way across the page, too. One way to do that is to remove the width from .bio-wrapper and then save and refresh. Your browser will assume that the percentage width for the .bio-boxes should be based on the width of the browser (Listing 42).
Listing 42: Style declarations can be empty.
index.html

.
.
.
.bio-wrapper {
}
.
.
.

images/figures/size_percent-bigger
Figure 35: The boxes are now taking up 50% of the width of the screen.

Now that the parent goes all the way across the screen, the child boxes definitely look bigger (Figure 35)!

Like we said above, percentage units work well for dimensions like width, but they behave a little strangely for height, and they don’t work at all for thickness—meaning you can’t use percentages for borders. In order for a percentage height to have an effect, the parent needs a set height (and even then things can get weird).

So, what if you wanted a box that was the height of the browser window? You’d think that setting a style to make it height: 100% would do the trick, but it won’t work. To see what we mean, add the code from Listing 43 at the top of your page above the h1.
Listing 43: Adding a test element for a quick and dirty example.
index.html

.
.
.
<div style="border:1px solid #000;width: 50%;height:100%;">I'm a percent
test</div>

<h1>I'm an h1</h1>
.
.
.

That will give you a box that is half the width of the page, but surprisingly only the height of the content that is inside of the div (Figure 36).
images/figures/percent_height-test
Figure 36: Not quite what you’d expect for height: 100%.

Let’s see what happens if instead we add a style that sets the height of the body element of the page, as shown in Listing 44. When you save and refresh, you’ll find that your “percent test” box has grown to be really tall (Figure 37).
Listing 44: Adding an absolute height to the parent.
index.html

.
.
.
/* GLOBAL STYLES */
body {
  height: 800px;
}
.
.
.

images/figures/percent_height-big
Figure 37: A more effective height: 100%.

What happened there? When you specify a height in percent, the parent container has to have some sort of defined height set in order for the child percent height to be applied. Otherwise the browser just makes the element the height needed to contain the content within. Because we added a height to the body tag, which naturally has to wrap all the content, it ended up working more like a suggested height.

Even though we made the percent height work, at times it will act differently from how you expect, as it is dependent on the end height of the parent container. If the content in the parent causes the element to expand to an unexpected size, you might end up with the percent height child display on screen as far larger than you wanted. Or, if you inadvertently add a style that removes the set height from the parent, the child element with a percentage height would suddenly return to being the height only of the content it contains (like in Figure 36). Don’t worry if this sounds confusing—just bear in mind that percent height is one of those properties whose behavior is liable to be unpredictable.

We’ll look at a some other solutions for getting elements to take up a proportion of a space later in the tutorial, both when we cover ways to make elements the size of the browser with the vh and vw units in Section 3.7, and then arrange to take up the full height of arbitrarily sized parents using the flexbox method in Chapter 7.

In the meantime, you should delete the “percent test” div from Listing 43, and make sure also to delete the style from Listing 44.
Percentage fonts

You can use percentages to set text sizes, but there is a consideration that you will have to keep in mind. If you use a percentage for a text size, the resulting size of the font is based not on the pixel dimensions of the container but rather on whatever font-size style that container has inherited. So the box itself could be 1000px tall, but if it inherited a font size of 16px, and you set the font size of a child element to 50%, you are going to get only an 8px-tall font (50% of 16px), not a 500px-tall font like you might think.

The fact that percentage sizing uses different sources for sizing the height and width of boxes (based on the actual pixel dimensions of an element) versus sizing text (based on inherited font size) is why it is only infrequently used for text sizing. Most people find it easier to think of percentages as a way of determining the size of box-shaped things, and use other relative sizing methods for fonts.

If that all sounds confusing, don’t worry—Section 3.5 will explain in greater detail using the em unit, whose behavior is similar to percentage. However, unlike percentage measurement, ems are regularly used for sizing text and less used for sizing boxes. (Warning: This is a potential holy war statement to make.)
Exercises

    Try setting a 10% margin on the .bio-box. This will push each box away from its neighbors by 10% of the width of the parent container, even the vertical margins (sharp-eyed readers might notice something weird with the vertical margins that we’ll discuss in Section 4.6).
    To see the way that percentage font sizes can be cumulative, set .bio-box font size to 150%, and then also set .bio-copy to 150%. The end result will be 150% of 150% of 16px (the page base font size), or in pixels… 

3.5 em

The em unit is a relative size unit that is commonly used for sizing text (most would say it is the preferred method). The name comes from the approximate width of the letter m, but this usage is mainly historical; in CSS, one em represents a number of pixels equal to the current font size of any given element’s parent container. If there is no font size that is inherited, then the default page font size is used.

For plain text (that is, not something like an h1 header), the default size is 16px, so the default size of an em is also 16px. Fractions of an em then represent fractions of the full font size; for example, if the font size is 16px, a unit of 0.5em would be 50% of 16, or 8px, and 2.25em would be 225% of 16, or 36px.

One of the things that makes ems useful, in comparison to something like pixel sizing, is that they automatically change value based on the font size that is inherited by the parent object that they are contained in. This means that if you used em sizing throughout your site, you can modify the entire site’s text simply by changing a single base font size, and all the fonts in all the child containers will resize in correct proportion based on this new declared font size. If you used pixels for everything, you’d have to change every declared font size by hand.

As an example, let’s say we set the font size of the .bio-copy to 0.5em, as shown in Listing 45. Because the default base font size of the entire page is 16px, the result in the browser is tiny 8px text, as shown in Figure 38.
Listing 45: Changing the bio copy font size.
index.html

.
.
.
/* BIO STYLES*/
.
.
.
.bio-copy {
  font-size: 0.5em;
}
.
.
.

images/figures/bio_copy_8px
Figure 38: The bio copy text after shrinking down to 0.5em.

Now let’s see the effect of changing the font size of the parent element. In Listing 40 we added a .bio-wrapper div to wrap the bio boxes, so we can redefine the base font size by adding a CSS rule as shown in Listing 46. The new rule in Listing 46 changes the font size from the default 16px to 24px, so the .bio-box font size of 0.5em is now 50% of 24, or 12px.
Listing 46: Setting a new base font size.
index.html

/* BIO STYLES */
.
.
.
.bio-wrapper {
  font-size: 24px;
}
.
.
.

To determine what the actual font size should be, the browser crawls up the parent/child tree until it finds a parent with a font size set with an absolute value, and then it calculates back down the tree to set the font sizes. As noted above, if there is no such absolute value the page default is 16px, but by changing the parent div to 24px we’ve managed to change the default for all child elements.

As a result, the font size of 0.5em is no longer 50% of 16, but rather is 50% of 24, for a total of 12px. The font size of the bio boxes automatically increases from the 8px shown in Figure 38 to 12px, as shown in Figure 39.
images/figures/size_em-small
Figure 39: The bio copy in the .bio-boxes has automatically increased.

One important property of em units is that they are cumulative: if an element has font size set to 0.5em appears inside an element whose font size is also 0.5em, then the resulting font size for that bottom child element is 0.5×0.5=

0.25em. In real numbers, if the base size is 24px, this means that the most deeply nested element is 25% of 24, or 6px. This cumulative effect can be helpful, or it can cause unintentional display errors—you just have to be careful.

Schematically, our current page consists of nested divs, with .bio-copy inside .bio-box inside .bio-wrapper. We already changed the font size of .bio-copy to 0.5em (Listing 45); if we change the .bio-box font size to 0.5em as well, the result will be 50% of 50% of 24, or 6px.
Listing 47: Adding a relative font size to the .bio-box.
index.html

.
.
.
.bio-box {
  border: 1px solid black;
  font-size: 0.5em;
  width: 50%;
}
.bio-copy {
  font-size: 0.5em;
}
.
.
.

Look at the resulting teeny tiny font (Figure 40)!
images/figures/size_em-tiny
Figure 40: Now the font size is unreadably tiny!

As outlined above, this happened because starting from the .bio-copy, the browser goes up one level to the parent and sees that there is a font size set, so it says, “OK, the font should be half the size of this parent size, but the .bio-box size is relative too, so let’s go up again until we find an absolute font size.” Going up one more level, the browser finds that .bio-wrapper declaration sets the font to 24px, so now it can work back down and set the .bio-box to 12px, and then the content inside the .bio-copy to 6px.

This works the other way too. If we set both .bio-box and .bio-copy a font sizes to 1.5em we’ll end up with giant font that is the equivalent of 54px font (24×1.5×1.5=

54px), as shown in Figure 41.
images/figures/size_em-huge
Figure 41: Now the font is just ridiculously huge.

Now that we’ve seen some crazy values, let’s change the bio copy to a more sensible font size of 1em (Listing 48).
Listing 48: A sensible font size for the bio copy.
index.html

.
.
.
.bio-copy {
  font-size: 1em;
}
.
.
.

So far we’ve used ems only for fonts, but the em unit can be used for things like margin, padding, and width (Chapter 4). In those cases, you have to remember that the size of an em is based on the local font size, so if you set a width for an object in em it will size the object based on the font size inside that element. For example, if the calculated font size in an element ends up being 16px, and you set the padding to 1.5em, then the padding will end up getting set to 1.5×16=

24px.

Sound confusing? Figure 42 shows a quick diagram to explain.
images/figures/size_em-padding
Figure 42: Dimensions inside the box get calculated based on the font size.

The argument for doing your sizing using ems is that all your elements, and their attributes like padding or margin, will be sized relative to the size of text. But just because we want to increase the size of fonts on a page doesn’t necessarily mean that we also want to change something like margin or padding. Sometimes you want the boxes that hold the content to stay the same and only the stuff inside to change, so styling every dimension of a container based on the text it contains can be inconvenient. As a result, in this tutorial we’ll use the em unit only for fonts.

Warning: As is often the case with such subjective judgments, this is holy-war territory (Figure 43).25
images/figures/holywar2
Figure 43: Well… that’s just, like, your opinion, man.
Exercises

    Give the .bio-box class a padding of 2.5em, and see how at small sizes the padding seems reasonable.
    Set the .bio-box font-size to 48px, and see how now your boxes’ padding is a significant percentage of the entire screen width.
    Set the .bio-box padding to a pixel size of 20px to see how that can make the spacing sizing independent from the content sizing. 

3.6 rem isn’t just for dreaming

The cumulative effect of the em unit (Section 3.5) can at times make designing layouts difficult since it makes it harder to drop sections of a page into other sections and be confident that you aren’t going to end up with some crazy cumulative sizing issue. (Recall the goal from Section 2.4 to make our markup as modular and Lego-like as possible.) In recent years browsers have implemented a new relative unit that allows for us to create modular sections that can be placed on the page without sizing uncertainties. One of the most useful of these units is the root em, or rem.

This rem unit works similarly to em, in that it is a percentage of an absolute font size, but instead of being cumulatively sized based on the whole parent/child tree, the rem unit always refers back to the font size of the html tagSpeaking of mobile-friendly units, we arrive now at two newer dimensional units that are also incredibly useful for responsive (mobile) layouts: the viewport height, vh, and viewport width, vw. These units allow us to size elements on the page based on the actual size of the browser window or mobile device screen. Each vh or vw is 1 percent of the corresponding screen dimension, so 3vh would equal 3% of the height of the screen and 100vw would be 100% of the width.
There is also an issue with the spacing around the h1, whose separate default margin is bleeding through the boundaries of the .full-hero parent due to something called margin collapsing
As useful as the viewport dimensions are, if we used them for everything our site would look bad on either mobile or desktop (depending on which platform you were using when you designed the page). Desktop windows are just so much bigger than mobile that elements designed to fit a mobile screen would look giant, and elements designed for desktop would look impossibly tiny on mobile.

The solution is to use a media query, which allows us to set different styles for elements based on the size of the user’s browser window
default size of 16px in 14-18px range.
Elements that are considered inline elements, like span or a, are only allowed to have margins and padding applied to the left and right (not top or bottom), and they won’t accept a width or height set by CSS. None of these restrictions apply to block elements

5 Display Property Values that affect the way elements are drawn:
html: float..
The display: none style prevents the element from displaying on the page.
 inline elements (such as links and spans) can’t have a width or height, but once you change the display property the dimensional styles get applied.
 display: block forces an element to be a block element regardless of what it was before. If you don’t set dimensions after changing an element to display: block, it will behave like any normal block element by taking up the entire width of its parent element
 display: inline turns a block element into an inline element (essentially the opposite of the display: block property)
 The inline-block property, which is a hybrid between inline and block, is a useful display setting, as it allows styling that normally works only on block elements—such as width and height, top margins, and padding—to be applied to a particular element. At the same time, it also lets the element as a whole act like an inline element.
 display: flex is a powerful display property that forces all child elements to fill the entire parent element
 It is also possible to fix the total width of the content box, and force the border and padding to fit inside. The way to do this is with the box-sizing declaration
 box-sizing: border-box;  The border-box property caused the browser to draw the borders and padding inside of the defined width.

The reason that the first example worked as expected is that the first two elements weren’t block elements, so the browser fully respected their set margins. Once they became block elements, though, the browser allowed for only one of the margins to apply
